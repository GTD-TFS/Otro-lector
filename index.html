<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî 2 capturas manuales (display vivo vertical, captura horizontal)</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  :root { --bg:#f6f7f9; --fg:#111; --card:#fff; }
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .card{background:var(--card);border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06);padding:1rem}

  h1{margin:.3rem 0 1rem}

  /* Contenedor del canvas: en vivo = vertical 9:16, en revisi√≥n = horizontal 16:9 */
  #stageWrap{position:relative;max-width:720px;margin:0 auto}
  #stageWrap.live  #stage{aspect-ratio:9/16}
  #stageWrap.review#stage{aspect-ratio:16/9}
  #stage{width:100%;background:#000;border-radius:12px;display:block;border:6px solid #ccc;transition:border-color .2s, aspect-ratio .2s}
  #stageWrap.good #stage{border-color:#22c55e}
  #stageWrap.mid  #stage{border-color:#eab308}
  #stageWrap.bad  #stage{border-color:#ef4444}
  #status{position:absolute;bottom:8px;left:0;right:0;text-align:center;color:#fff;background:rgba(0,0,0,.45);padding:6px;border-radius:10px;font-size:.95rem}

  .toolbar{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;margin:.75rem 0}
  button,label.btn{padding:.65rem .9rem;border:none;border-radius:10px;cursor:pointer;background:#111;color:#fff;font-size:1rem}
  button:disabled{opacity:.55;cursor:not-allowed}

  .row{display:flex;gap:1rem;justify-content:center;color:#555}
  input[type=range]{width:160px}
  #counter{text-align:center;color:#555;margin:.25rem 0}

  textarea{width:100%;min-height:160px;margin-top:.5rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî 2 capturas manuales</h1>

    <div id="stageWrap" class="live bad">
      <canvas id="stage"></canvas>
      <div id="status">Pulsa ‚ÄúHacer foto‚Äù para iniciar la c√°mara (display vertical)</div>
    </div>

    <div id="counter">0 / 2 capturas</div>

    <div class="row">
      <div>üåó Contraste: <input id="contrast" type="range" min="0.8" max="2.2" step="0.05" value="1.6"></div>
      <div>üü° Brillo: <input id="brightness" type="range" min="0.7" max="1.5" step="0.05" value="1.0"></div>
    </div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*" style="display:none">
      </label>
      <button id="shoot">üì∑ Hacer foto</button>
      <button id="ocr" disabled>üìñ Leer OCR</button>
    </div>

    <h3>Texto</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (normalizados)</h3>
    <pre id="fields"></pre>
  </div>
</div>

<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const stageWrap = $('stageWrap');
  const stage = $('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = $('status');
  const contrast = $('contrast');
  const brightness = $('brightness');
  const fileInput = $('file');
  const shootBtn = $('shoot');
  const ocrBtn = $('ocr');
  const counter = $('counter');
  const out = $('out');
  const fieldsEl = $('fields');

  // ====== Estado ======
  let video = document.createElement('video'); video.autoplay=true; video.muted=true; video.playsInline=true;
  let stream = null, running = false, inLive = false;
  let sources = [];            // blobs PNG horizontales (m√°x. 2)
  let shootInProgress = false; // antirrebote

  // Canvas visible (tama√±o cambia por modo), y canvas l√≥gico horizontal (16:9) que se OCRiza
  function setLiveCanvasSize(){ stage.width = 900;  stage.height = 1600; }   // 9:16 (vertical)
  function setReviewCanvasSize(){ stage.width = 1600; stage.height = 900; }  // 16:9 (horizontal)
  setLiveCanvasSize();

  const logical = document.createElement('canvas'); // SIEMPRE horizontal 16:9
  logical.width = 1600; logical.height = 900;
  const lctx = logical.getContext('2d', { willReadFrequently:true });

  function setCounter(){
    counter.textContent = `${sources.length} / 2 capturas`;
    ocrBtn.disabled = sources.length === 0;
  }

  // ====== Filtros B/N ======
  function applyBW(ctx2d, w, h){
    const data = ctx2d.getImageData(0,0,w,h);
    const d = data.data;
    const c = parseFloat(contrast.value);
    const b = parseFloat(brightness.value);
    for (let i=0;i<d.length;i+=4){
      let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      g = g * c * b; if (g<0) g=0; if (g>255) g=255;
      d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx2d.putImageData(data,0,0);
  }

  // ====== Render ‚Äúl√≥gico‚Äù (siempre horizontal 16:9): ROTAR si hace falta + COVER + B/N ======
  function renderToLogicalHorizontal(source){
    // Normaliza la fuente a horizontal antes del recorte
    const sw0 = source.videoWidth || source.width;
    const sh0 = source.videoHeight || source.height;

    // Si la fuente es vertical, rotamos 90¬∞ a un canvas temporal
    let srcCanvas = document.createElement('canvas'), sctx = srcCanvas.getContext('2d');
    if (sh0 > sw0){
      srcCanvas.width = sh0; srcCanvas.height = sw0;
      sctx.translate(srcCanvas.width/2, srcCanvas.height/2);
      sctx.rotate(Math.PI/2);
      sctx.drawImage(source, -sw0/2, -sh0/2);
    } else {
      srcCanvas.width = sw0; srcCanvas.height = sh0;
      sctx.drawImage(source, 0, 0);
    }

    // Recorte COVER a 16:9 dentro del canvas l√≥gico
    const sw = srcCanvas.width, sh = srcCanvas.height;
    const targetRatio = logical.width / logical.height; // 16:9
    const srcRatio = sw / sh;
    let sx, sy, cw, ch;
    if (srcRatio > targetRatio){
      ch = sh; cw = Math.round(sh * targetRatio);
      sx = Math.round((sw - cw)/2); sy = 0;
    } else {
      cw = sw; ch = Math.round(sw / targetRatio);
      sx = 0; sy = Math.round((sh - ch)/2);
    }

    // Dibujar en l√≥gico horizontal
    lctx.clearRect(0,0,logical.width,logical.height);
    lctx.drawImage(srcCanvas, sx, sy, cw, ch, 0, 0, logical.width, logical.height);

    // Filtro B/N
    applyBW(lctx, logical.width, logical.height);
  }

  // ====== Mostrar en VIVO (display vertical): pintar el l√≥gico (horizontal) ROTADO + COVER al canvas visible ======
  function paintLiveFromLogical(){
    ctx.save();
    ctx.clearRect(0,0,stage.width,stage.height);

    // El canvas visible est√° en 9:16; dibujamos el ‚Äúlogical‚Äù horizontal rotado 90¬∫ para que t√∫ lo veas horizontal dentro del display vertical
    ctx.translate(stage.width/2, stage.height/2);
    ctx.rotate(-Math.PI/2); // gira 90¬∫ para mostrarlo horizontal en el display vertical
    ctx.drawImage(logical, -stage.height/2, -stage.width/2, stage.height, stage.width);
    ctx.restore();
  }

  // ====== Mostrar en REVISI√ìN (display horizontal): pintar l√≥gico tal cual ======
  function paintReviewFromLogical(){
    ctx.clearRect(0,0,stage.width,stage.height);
    ctx.drawImage(logical, 0, 0, stage.width, stage.height);
  }

  // ====== Calidad (nivel 5) ======
  function focusScore(){
    const c = document.createElement('canvas');
    c.width = 160; c.height = 90;
    const x = c.getContext('2d');
    x.drawImage(video, 0, 0, c.width, c.height);
    const d = x.getImageData(0,0,c.width,c.height).data;
    const gray = new Float32Array(c.width*c.height);
    for (let i=0,j=0;i<d.length;i+=4,j++) gray[j]=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    let mean=0; for(const g of gray) mean+=g; mean/=gray.length;
    let variance=0; for(const g of gray) variance+=(g-mean)**2; variance/=gray.length;
    return variance/100;
  }
  function brightnessScore(){
    const c=document.createElement('canvas'); c.width=64; c.height=36;
    const x=c.getContext('2d'); x.drawImage(video,0,0,c.width,c.height);
    const d=x.getImageData(0,0,c.width,c.height).data; let sum=0,n=d.length/4;
    for (let i=0;i<d.length;i+=4) sum+=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    return sum/n;
  }
  function updateQuality(){
    const f=focusScore(), br=brightnessScore();
    let state='bad';
    if (f>35 && br>35 && br<230) state='good';
    else if (f>20 && br>25 && br<245) state='mid';
    stageWrap.classList.remove('good','mid','bad');
    stageWrap.classList.add(state);
    if (state==='good') statusEl.textContent='‚úÖ Enfocado y buena luz (display en vertical, contenido horizontal)';
    else if (state==='mid') statusEl.textContent='üü° Ajusta un poco (enfoque/luz)';
    else statusEl.textContent='üî¥ Borroso o con reflejos';
  }

  // ====== C√°mara en vivo ======
  async function startCamera(){
    if (stream) return;
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} }
      });
      video.srcObject = stream;
      await video.play();
      running = true; inLive = true;
      stageWrap.classList.remove('review'); stageWrap.classList.add('live');
      setLiveCanvasSize();
      statusEl.textContent='Vista previa en vivo (display vertical). Gira el m√≥vil para ver el documento horizontal.';
      loop();
    }catch(e){ console.error(e); statusEl.textContent='‚ùå No se pudo iniciar la c√°mara'; }
  }
  function stopCamera(){
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    running=false; inLive=false;
  }
  function loop(){
    if (!running) return;
    // 1) Renderizamos al canvas l√≥gico horizontal (16:9) desde el v√≠deo
    renderToLogicalHorizontal(video);
    // 2) Pintamos al display vertical rotando el l√≥gico
    paintLiveFromLogical();
    updateQuality();
    requestAnimationFrame(loop);
  }

  // ====== Captura desde c√°mara ======
  async function captureFromCamera(){
    if (shootInProgress) return;
    shootInProgress = true; shootBtn.disabled = true;

    // El l√≥gico YA contiene el frame actual procesado en B/N. Guardamos su blob (horizontal 16:9)
    const blob = await new Promise(res => logical.toBlob(res,'image/png',1));
    sources.push(blob);
    setCounter();

    // Pasar a revisi√≥n horizontal mostrando exactamente lo capturado
    stopCamera();
    stageWrap.classList.remove('live'); stageWrap.classList.add('review');
    setReviewCanvasSize();
    paintReviewFromLogical();
    statusEl.textContent = sources.length>=2
      ? 'üßä Capturas completas (2/2). Listo para OCR.'
      : 'üßä Captura guardada (1/2). Puedes hacer otra foto.';

    shootInProgress = false; shootBtn.disabled = false;
  }

  // ====== Cargar desde dispositivo ======
  fileInput.addEventListener('change', async e => {
    const f = e.target.files?.[0]; if (!f) return;
    // Renderizamos al ‚Äúl√≥gico‚Äù horizontal usando la imagen cargada
    const img = await createImageBitmap(f);
    renderToLogicalHorizontal(img);
    // Mostrar en revisi√≥n horizontal
    stopCamera();
    stageWrap.classList.remove('live'); stageWrap.classList.add('review');
    setReviewCanvasSize();
    paintReviewFromLogical();
    // Guardar como captura
    const blob = await new Promise(res => logical.toBlob(res,'image/png',1));
    sources.push(blob); setCounter();
    statusEl.textContent='üñºÔ∏è Imagen cargada (B/N). Puedes a√±adir otra o leer OCR.';
    fileInput.value = '';
  });

  // ====== Controles ======
  $('shoot').addEventListener('click', async () => {
    if (!inLive) await startCamera(); else await captureFromCamera();
  });
  contrast.addEventListener('input', () => {
    if (inLive) { renderToLogicalHorizontal(video); paintLiveFromLogical(); }
    else { paintReviewFromLogical(); } // en revisi√≥n, el l√≥gico ya est√° con B/N aplicado; si quieres re-aplicar, recalc√∫lalo con una copia guardada
  });
  brightness.addEventListener('input', () => {
    if (inLive) { renderToLogicalHorizontal(video); paintLiveFromLogical(); }
    else { paintReviewFromLogical(); }
  });

  // ====== OCR ======
  $('ocr').addEventListener('click', async () => {
    if (!sources.length) return;
    out.value = `Procesando OCR (${sources.length} imagen${sources.length>1?'es':''})‚Ä¶`;
    fieldsEl.textContent = '';

    const worker = await Tesseract.createWorker('spa', 1, { logger: m => console.log(m) });
    const texts=[], parsed=[];
    for (let i=0;i<sources.length;i++){
      const { data } = await worker.recognize(sources[i]);
      const t = (data.text||'').trim();
      texts.push(t); parsed.push(parseDNI(t));
    }
    await worker.terminate();

    out.value = (sources.length===2) ? fuseText(texts) : texts[0];
    const fused = (sources.length===2) ? fuseParsed(parsed) : parsed[0];
    fieldsEl.textContent = JSON.stringify(fused, null, 2);
  });

  // ====== Parser y consenso ======
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }
  function parseDNI(text){
    const clean = norm(text);
    const out = { "Nombre":"", "Apellidos":"", "Tipo documento":"DNI", "N¬∫ Documento":"", "Sexo":"", "Nacionalidad":"", "Fecha nacimiento":"" };
    const mDni = clean.match(/\b\d{8}[A-Z]\b/); if (mDni) out["N¬∫ Documento"]=mDni[0];
    const lines = clean.split(/\n| {2,}/);
    for (let i=0;i<lines.length;i++){ const l=lines[i];
      if (l.includes("APELLID")) out["Apellidos"]=(lines[i+1]||"").split(' ').slice(0,4).join(' ');
      if (l.includes("NOMBRE"))  out["Nombre"]  =(lines[i+1]||"").split(' ').slice(0,3).join(' ');
    }
    const mLine = clean.match(/\b[MF]\b.*?\b[A-Z]{3}\b.*?\b\d{1,2} \d{1,2} \d{4}\b/);
    if (mLine){ const parts=mLine[0].split(/\s+/);
      out["Sexo"]=parts[0];
      out["Nacionalidad"]=parts.find(p=>p.length===3&&/[A-Z]{3}/.test(p))||"";
      const f=mLine[0].match(/\d{1,2} \d{1,2} \d{4}/); if(f) out["Fecha nacimiento"]=f[0].replace(/\s/g,'/');
    }
    return out;
  }
  function fuseText(texts){
    const toks = texts.map(t=>t.split(/\s+/));
    const max = Math.max(...toks.map(a=>a.length)); const res=[];
    for (let i=0;i<max;i++){
      const col = toks.map(a=>a[i]).filter(Boolean);
      if (!col.length) continue;
      const m = majority(col); res.push(m||centroidString(col));
    }
    return res.join(' ');
  }
  function fuseParsed(list){
    const keys=Object.keys(list[0]); const res={};
    for (const k of keys){
      const vals = list.map(o=>(o[k]||'').trim()).filter(Boolean);
      if (!vals.length){ res[k]=''; continue; }
      const m = majority(vals); res[k] = m || centroidString(vals);
    }
    if (res["Apellidos"]) res["Apellidos"]=res["Apellidos"].replace(/\s{2,}/g,' ').trim();
    return res;
  }
  function majority(arr){ const map=new Map(); for(const v of arr) map.set(v,(map.get(v)||0)+1);
    let best=null,cnt=0; for(const [v,c] of map.entries()) if(c>cnt){cnt=c;best=v;}
    const ties=[...map.values()].filter(c=>c===cnt).length; return ties>1?null:best; }
  function centroidString(arr){ let best=null,score=Infinity;
    for(const a of arr){ let s=0; for(const b of arr){ s+=lev(a,b); } if(s<score){score=s;best=a;} }
    return best||arr[0]; }
  function lev(a,b){ const m=a.length,n=b.length,dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
    for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j;
    for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const c=a[i-1]===b[j-1]?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+c); } } return dp[m][n]; }
})();
</script>
</body>
</html>
