<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî Cargar ‚Üí Autogiro 180¬∞ ‚Üí Campos</title>
<style>
  body{margin:0;background:#f6f7f9;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .card{background:#fff;padding:1rem;border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06)}
  h1{margin:.25rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{margin-top:.75rem;display:flex;justify-content:center}
  label.btn{padding:.7rem 1rem;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  label.btn input{display:none}
  #status{margin-top:.6rem;text-align:center;color:#555;word-break:break-word}
  textarea{width:100%;min-height:140px;margin-top:.75rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî Carga √∫nica (autogiro 180¬∞, campos b√°sicos)</h1>

    <canvas id="stage"></canvas>
    <div id="status">Elige una foto del dispositivo. Se normaliza a horizontal, se corrige si est√° boca abajo y se lanza OCR autom√°tico.</div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*">
      </label>
    </div>

    <h3>Texto OCR</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (normalizados)</h3>
    <pre id="fields"></pre>

    <h3>Array exportaci√≥n</h3>
    <pre id="exportArr"></pre>
  </div>
</div>

<!-- Tesseract -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const stage = document.getElementById('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = document.getElementById('status');
  const fileInput = document.getElementById('file');
  const out = document.getElementById('out');
  const fieldsEl = document.getElementById('fields');
  const exportEl = document.getElementById('exportArr');

  const OUT_W = 1800, OUT_H = 1012; // 16:9
  stage.width = OUT_W; stage.height = OUT_H;

  // ===== Helpers canvas =====
  function cover16x9(srcCanvas, tw=OUT_W, th=OUT_H){
    const sw = srcCanvas.width, sh = srcCanvas.height;
    const target = tw/th, ratio = sw/sh;
    let sx, sy, cw, ch;
    if (ratio > target) { ch = sh; cw = Math.round(sh * target); sx = Math.round((sw - cw)/2); sy = 0; }
    else { cw = sw; ch = Math.round(sw / target); sx = 0; sy = Math.round((sh - ch)/2); }
    const c = document.createElement('canvas'); c.width = tw; c.height = th;
    c.getContext('2d').drawImage(srcCanvas, sx, sy, cw, ch, 0, 0, tw, th);
    return c;
  }
  function rotate180(srcCanvas){
    const c = document.createElement('canvas'); c.width = srcCanvas.width; c.height = srcCanvas.height;
    const x = c.getContext('2d');
    x.translate(c.width, c.height);
    x.rotate(Math.PI);
    x.drawImage(srcCanvas, 0, 0);
    return c;
  }
  function ensureLandscape(imgBitmap){
    // Si viene alta>ancha, gira 90¬∞ a paisaje
    const sw = imgBitmap.width, sh = imgBitmap.height;
    const c = document.createElement('canvas');
    const x = c.getContext('2d');
    if (sh > sw){
      c.width = sh; c.height = sw;
      x.translate(c.width/2, c.height/2);
      x.rotate(Math.PI/2);
      x.drawImage(imgBitmap, -sw/2, -sh/2);
    } else {
      c.width = sw; c.height = sh;
      x.drawImage(imgBitmap, 0, 0);
    }
    return c;
  }

  // ===== Preprocesado para OCR (autom√°tico, fino) =====
  function prepForOCR(fromCanvas){
    // Copia ‚Üí gris ‚Üí Otsu ‚Üí unsharp suave 3x3
    const w = fromCanvas.width, h = fromCanvas.height;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const x = c.getContext('2d', { willReadFrequently:true });
    x.drawImage(fromCanvas, 0, 0);

    let img = x.getImageData(0,0,w,h);
    let d = img.data;
    const gray = new Uint8ClampedArray(w*h);
    for (let i=0,j=0;i<d.length;i+=4,j++){
      gray[j] = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    }
    const thr = otsu(gray);
    for (let j=0,i=0;j<gray.length;j++,i+=4){
      const v = gray[j] > thr ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
    }
    x.putImageData(img,0,0);
    unsharp(x,w,h);
    return c;
  }
  function otsu(gray){
    const hist = new Uint32Array(256);
    let sum = 0, total = gray.length;
    for (let i=0;i<total;i++){ hist[gray[i]]++; sum += gray[i]; }
    let sumB=0, wB=0, wF=0, mB=0, mF=0, varMax=0, threshold=127;
    for (let t=0;t<256;t++){
      wB += hist[t]; if (wB===0) continue;
      wF = total - wB; if (wF===0) break;
      sumB += t*hist[t];
      mB = sumB / wB;
      mF = (sum - sumB) / wF;
      const between = wB*wF*(mB-mF)*(mB-mF);
      if (between > varMax){ varMax = between; threshold = t; }
    }
    return threshold;
  }
  function unsharp(ctx, w, h){
    const src = ctx.getImageData(0,0,w,h);
    const dst = ctx.createImageData(w,h);
    const s = src.data, d = dst.data;
    const idx = (x,y)=> (y*w + x) * 4;
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        const i = idx(x,y);
        const up   = idx(x, y-1);
        const left = idx(x-1,y);
        const right= idx(x+1,y);
        const down = idx(x, y+1);
        // sharpening sobre valor gris (los 3 canales iguales)
        let v = - s[up] - s[left] + 5*s[i] - s[right] - s[down];
        v = v<0?0:(v>255?255:v);
        d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
      }
    }
    ctx.putImageData(dst,0,0);
  }

  // ===== Text utils / parser =====
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }

  // Punt√∫a si el texto "parece DNI derecho"
  function keywordScore(text){
    const T = norm(text);
    const keys = ["NOMBRE","APELLID","SEXO","NACIONALIDAD","ESP","DNI","SOPORT","VALIDEZ","NACIM"];
    let score=0;
    for (const k of keys){ if (T.includes(k)) score++; }
    // Bono si detecta un NIF y una fecha razonable
    if (/\b\d{8}[A-Z]\b/.test(T)) score+=2;
    if (/\b\d{1,2}[\/.\-\s]\d{1,2}[\/.\-\s]\d{4}\b/.test(T)) score+=1;
    return score;
  }

  function parseFields(text){
    const clean = norm(text);
    const now = new Date(); const thisYear = now.getFullYear(); const minYear = thisYear - 100;

    const out = {
      "Nombre": "",
      "APELLIDOS": "",
      "TIPO DOCUMENTO": "DNI",
      "N¬∫DOCUMENTO": "",
      "SEXO": "",
      "NACIONALIDAD": "",
      "Nombre de los Padres": "",
      "FECHA DE NACIMIENTO": "",
      "LUGAR DE NACIMIENTO": "",
      "DOMICILIO": ""
    };

    // N¬∫ DOCUMENTO: 8 d√≠gitos + letra
    const mDni = clean.match(/\b\d{8}[A-Z]\b/);
    if (mDni) out["N¬∫DOCUMENTO"] = mDni[0];

    // FECHA NAC: dd mm aaaa con a√±o l√≥gico
    const fechas = [...clean.matchAll(/\b(\d{1,2})[\/\.\-\s](\d{1,2})[\/\.\-\s](\d{4})\b/g)];
    for (const f of fechas) {
      const d = parseInt(f[1],10), m = parseInt(f[2],10), y = parseInt(f[3],10);
      if (y>=minYear && y<=thisYear && d>=1 && d<=31 && m>=1 && m<=12) {
        out["FECHA DE NACIMIENTO"] = `${String(d).padStart(2,'0')}/${String(m).padStart(2,'0')}/${y}`;
        break;
      }
    }

    // SEXO: M/F ‚Üí Masculino/Femenino
    const mSex = clean.match(/\b([MF])\b/);
    if (mSex) out["SEXO"] = (mSex[1] === 'M') ? 'Masculino' : 'Femenino';

    // NACIONALIDAD: 3 letras, prioriza ESP
    const mNat = clean.match(/\bESP\b/) || clean.match(/\b[A-Z]{3}\b/);
    if (mNat) out["NACIONALIDAD"] = mNat[0];

    // === Nombre / Apellidos por anclaje (versi√≥n actual y pen√∫ltima) ===
    const lines = clean.split(/\n+/).map(s=>s.trim()).filter(Boolean);

    // 1) Nombre: l√≠nea tras "NOMBRE" o la parte de la propia l√≠nea que no sea "NOMBRE"
    let idxN = lines.findIndex(l => /\bNOMBRE\b/.test(l));
    if (idxN >= 0){
      // candidato en la misma l√≠nea (despu√©s de NOMBRE) o l√≠nea siguiente
      let same = lines[idxN].replace(/.*\bNOMBRE\b[:\- ]*/,'').trim();
      let next = (lines[idxN+1]||'').trim();
      const pick = chooseNameCandidate([same, next]);
      if (pick) out["Nombre"] = pick;
      // 2) Apellidos: buscar arriba 1-3 l√≠neas con may√∫sculas no-etiqueta
      const windowLines = lines.slice(Math.max(0, idxN-3), idxN+1);
      const ap = guessSurnames(windowLines);
      if (ap) out["APELLIDOS"] = ap;
    } else {
      // Fallback: si aparece "APELLID" usar siguiente(s) como apellidos y buscar cerca un nombre de 1-3 tokens
      const idxA = lines.findIndex(l => /APELLID/.test(l));
      if (idxA >= 0){
        const a1 = (lines[idxA+1]||'').trim();
        const a2 = (lines[idxA+2]||'').trim();
        const ap = [a1,a2].filter(Boolean).map(cleanTokens).join(' ').trim();
        if (ap) out["APELLIDOS"]=ap;
        // Nombre en las 3 l√≠neas siguientes
        const nameWin = lines.slice(idxA+1, idxA+4);
        const nm = chooseNameCandidate(nameWin);
        if (nm) out["Nombre"]=nm;
      }
    }

    return out;
  }

  function cleanTokens(s){
    return s.replace(/\b(NOMBRE|APELLIDOS?|SEXO|NACIONALIDAD|NACIMIENTO|EMISION|VALIDEZ|SOPORTE|DOCUMENTO|DNI|TITULAR)\b/g,'')
            .replace(/[^A-Z√Å√â√ç√ì√ö√ú√ë\s\-']/g,' ')
            .replace(/\s+/g,' ')
            .trim();
  }

  function chooseNameCandidate(arr){
    // Elige 1‚Äì3 tokens con pinta de nombre propio (‚â•3 letras), evita etiquetas
    for (const raw of arr){
      const s = cleanTokens(raw||'');
      if (!s) continue;
      const toks = s.split(/\s+/).filter(t=>t.length>=2 && !/^\d+$/.test(t));
      if (!toks.length) continue;
      // preferir 1‚Äì2 tokens
      const best = toks.slice(0, Math.min(3, toks.length)).join(' ');
      if (best.length >= 3) return best;
    }
    return '';
  }

  function guessSurnames(linesBlock){
    // Busca dos palabras largas (>=3) en l√≠neas superiores que no sean etiquetas
    const candidates = [];
    for (const L of linesBlock){
      const s = cleanTokens(L);
      if (!s) continue;
      const toks = s.split(/\s+/).filter(t=>t.length>=2 && !/^\d+$/.test(t));
      // si tiene 2+ tokens, buen candidato
      if (toks.length>=2) candidates.push(toks.slice(0,2).join(' '));
      else if (toks.length===1) candidates.push(toks[0]);
    }
    // intenta unir dos l√≠neas si son sueltos
    if (!candidates.length) return '';
    const joined = candidates.join(' ').split(/\s+/).filter(Boolean);
    const res = joined.slice(0,2).join(' ').trim();
    return res || '';
  }

  function buildExportArray(data){
    const U = s => (s||'').toString();
    const domDisplay = data["DOMICILIO"] || "";
    return [
      ["Nombre", U(data["Nombre"])],
      ["Apellidos", U(data["APELLIDOS"])],
      ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
      ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
      ["Sexo", U(data["SEXO"])],
      ["Nacionalidad", U(data["NACIONALIDAD"])],
      ["Nombre de los Padres", U(data["Nombre de los Padres"])],
      ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
      ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
      ["Domicilio", U(domDisplay)],
    ];
  }

  // ===== OCR pipeline con autogiro 180¬∞ =====
  async function quickOCR(canvas){
    const blob = await new Promise(res => canvas.toBlob(res,'image/png',0.92));
    const worker = await Tesseract.createWorker('spa', 1);
    await worker.setParameters({ tessedit_pageseg_mode: 6 });
    const { data } = await worker.recognize(blob);
    await worker.terminate();
    return (data.text||'').trim();
  }

  async function fullOCR(canvas){
    const blob = await new Promise(res => canvas.toBlob(res,'image/png',0.92));
    const worker = await Tesseract.createWorker('spa', 1);
    await worker.setParameters({ tessedit_pageseg_mode: 6 });
    const { data } = await worker.recognize(blob);
    await worker.terminate();
    return (data.text||'').trim();
  }

  async function runAutoOCR(baseCanvas /* ya horizontal 16:9 */){
    // 1) Preprocesar (Otsu+unsharp) ‚Üí OCR r√°pido para score
    const pre = prepForOCR(baseCanvas);
    const text0 = await quickOCR(pre);
    const score0 = keywordScore(text0);

    // 2) Prueba girar 180¬∞ y compara
    const pre180 = prepForOCR(rotate180(baseCanvas));
    const text180 = await quickOCR(pre180);
    const score180 = keywordScore(text180);

    let chosenCanvas = baseCanvas;
    let textChosen = text0;
    if (score180 > score0) {
      chosenCanvas = rotate180(baseCanvas);
      textChosen = text180;
      // redibuja la vista a ‚Äústage‚Äù para que t√∫ tambi√©n la veas correctamente
      ctx.clearRect(0,0,OUT_W,OUT_H);
      ctx.drawImage(chosenCanvas,0,0);
      statusEl.textContent = '‚Üª Detectado boca abajo: girado 180¬∞ autom√°ticamente. Ejecutando OCR final‚Ä¶';
    } else {
      statusEl.textContent = '‚úÖ Orientaci√≥n correcta. Ejecutando OCR final‚Ä¶';
    }

    // 3) OCR ‚Äúbueno‚Äù (preprocesado fino) sobre la orientaci√≥n elegida
    const finalPre = prepForOCR(chosenCanvas);
    const finalText = await fullOCR(finalPre);

    return finalText;
  }

  // ===== Carga de archivo =====
  async function loadFromFile(file){
    statusEl.textContent = 'Cargando imagen‚Ä¶';
    const bmp = await createImageBitmap(file); // EXIF suele venir aplicado por el navegador
    // Normalizar a paisaje + encuadrar 16:9
    const landscape = ensureLandscape(bmp);
    const base = cover16x9(landscape, OUT_W, OUT_H);

    // Mostrarte lo que se usar√°
    ctx.clearRect(0,0,OUT_W,OUT_H);
    ctx.drawImage(base,0,0);

    // OCR auto con autogiro
    statusEl.textContent = 'Analizando orientaci√≥n y leyendo‚Ä¶';
    const finalText = await runAutoOCR(base);

    out.value = finalText;

    const parsed = parseFields(finalText);
    fieldsEl.textContent = JSON.stringify(parsed, null, 2);
    exportEl.textContent = JSON.stringify(buildExportArray(parsed), null, 2);

    statusEl.textContent = '‚úÖ OCR completado.';
  }

  // ===== Eventos =====
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    try { await loadFromFile(f); }
    catch(err){ console.error(err); statusEl.textContent='‚ùå Error cargando/OCR.'; }
    finally { e.target.value=''; }
  });

  // ====== (Para tu ejemplo aportado) qu√© sacar√≠a el parser ======
  // Con el texto que pasaste, el parser asignar√≠a:
  // Nombre: CRISTINA
  // Apellidos: NAVARRETE NAVARRO
  // N¬∫DOCUMENTO: 51578798X
  // SEXO: (detecta F ‚Üí Femenino, M ‚Üí Masculino)
  // FECHA DE NACIMIENTO: 29/10/1965
  // NACIONALIDAD: ESP
})();
</script>
</body>
</html>
