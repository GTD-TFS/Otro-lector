<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî 2 capturas manuales horizontales</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  :root { --bg:#f6f7f9; --fg:#111; --card:#fff; }
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .card{background:var(--card);border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06);padding:1rem}
  h1{margin:.3rem 0 1rem}
  #stageWrap{position:relative;max-width:720px;margin:0 auto}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block;border:6px solid #ccc;transition:border-color .2s}
  #stageWrap.good #stage{border-color:#22c55e}
  #stageWrap.mid  #stage{border-color:#eab308}
  #stageWrap.bad  #stage{border-color:#ef4444}
  #status{position:absolute;bottom:8px;left:0;right:0;text-align:center;color:#fff;background:rgba(0,0,0,.45);padding:6px;border-radius:10px;font-size:.95rem}
  .toolbar{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;margin:.75rem 0}
  button,label.btn{padding:.65rem .9rem;border:none;border-radius:10px;cursor:pointer;background:#111;color:#fff;font-size:1rem}
  button:disabled{opacity:.55;cursor:not-allowed}
  .row{display:flex;gap:1rem;justify-content:center;color:#555}
  input[type=range]{width:160px}
  #counter{text-align:center;color:#555;margin:.25rem 0}
  textarea{width:100%;min-height:160px;margin-top:.5rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî 2 capturas manuales (B/N, horizontal)</h1>

    <div id="stageWrap" class="bad">
      <canvas id="stage"></canvas>
      <div id="status">Pulsa ‚ÄúHacer foto‚Äù para iniciar la c√°mara</div>
    </div>
    <div id="counter">0 / 2 capturas</div>

    <div class="row">
      <div>üåó Contraste: <input id="contrast" type="range" min="0.8" max="2.2" step="0.05" value="1.6"></div>
      <div>üü° Brillo: <input id="brightness" type="range" min="0.7" max="1.5" step="0.05" value="1.0"></div>
    </div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*" style="display:none">
      </label>
      <button id="shoot">üì∑ Hacer foto</button>
      <button id="ocr" disabled>üìñ Leer OCR</button>
    </div>

    <h3>Texto</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (normalizados)</h3>
    <pre id="fields"></pre>
  </div>
</div>

<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const stageWrap = $('stageWrap');
  const stage = $('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = $('status');
  const contrast = $('contrast');
  const brightness = $('brightness');
  const fileInput = $('file');
  const shootBtn = $('shoot');
  const ocrBtn = $('ocr');
  const counter = $('counter');
  const out = $('out');
  const fieldsEl = $('fields');

  // Estado
  let video = document.createElement('video'); video.autoplay=true; video.muted=true; video.playsInline=true;
  let stream = null, running = false;
  let lastImage = null;          // √∫ltima imagen cargada para re-render con sliders
  let sources = [];              // blobs PNG B/N (m√°x. 2)
  let shootInProgress = false;   // antirrebote

  // Canvas 16:9 grande
  function initCanvas(){ stage.width = 1600; stage.height = 900; }
  initCanvas(); window.addEventListener('resize', initCanvas);

  function setCounter(){
    counter.textContent = `${sources.length} / 2 capturas`;
    ocrBtn.disabled = sources.length === 0;
  }

  // ---- Dibujado SIEMPRE HORIZONTAL: rotar si el sensor viene vertical ----
  function drawBWHorizontal(source){
    // 1) Normalizar a horizontal (si alto>ancho, rotamos 90¬∫)
    const sw0 = source.videoWidth || source.width;
    const sh0 = source.videoHeight || source.height;

    const srcCanvas = document.createElement('canvas');
    const sctx = srcCanvas.getContext('2d');

    if (sh0 > sw0) {
      // rotamos a paisaje
      srcCanvas.width = sh0; srcCanvas.height = sw0;
      sctx.translate(srcCanvas.width/2, srcCanvas.height/2);
      sctx.rotate(Math.PI/2);
      sctx.drawImage(source, -sw0/2, -sh0/2);
    } else {
      srcCanvas.width = sw0; srcCanvas.height = sh0;
      sctx.drawImage(source, 0, 0);
    }

    // 2) Recorte cover a 16:9
    const sw = srcCanvas.width, sh = srcCanvas.height;
    const targetRatio = stage.width / stage.height;
    const srcRatio = sw / sh;
    let sx, sy, cw, ch;
    if (srcRatio > targetRatio){
      ch = sh; cw = Math.round(sh * targetRatio);
      sx = Math.round((sw - cw)/2); sy = 0;
    } else {
      cw = sw; ch = Math.round(sw / targetRatio);
      sx = 0; sy = Math.round((sh - ch)/2);
    }

    ctx.clearRect(0,0,stage.width,stage.height);
    ctx.drawImage(srcCanvas, sx, sy, cw, ch, 0, 0, stage.width, stage.height);

    // 3) B/N + contraste/brillo (lo que ves = lo que se guarda)
    const data = ctx.getImageData(0,0,stage.width,stage.height);
    const d = data.data;
    const c = parseFloat(contrast.value);
    const b = parseFloat(brightness.value);
    for (let i=0;i<d.length;i+=4){
      let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      g = g * c * b; if (g<0) g=0; if (g>255) g=255;
      d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(data,0,0);
  }

  // ---- Calidad (nivel 5) ----
  function focusScore(){
    const c = document.createElement('canvas');
    c.width = 160; c.height = 90;
    const x = c.getContext('2d');
    x.drawImage(video, 0, 0, c.width, c.height);
    const d = x.getImageData(0,0,c.width,c.height).data;
    const gray = new Float32Array(c.width*c.height);
    for (let i=0,j=0;i<d.length;i+=4,j++) gray[j]=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    let mean=0; for(const g of gray) mean+=g; mean/=gray.length;
    let variance=0; for(const g of gray) variance+=(g-mean)**2; variance/=gray.length;
    return variance/100;
  }
  function brightnessScore(){
    const c=document.createElement('canvas'); c.width=64; c.height=36;
    const x=c.getContext('2d'); x.drawImage(video,0,0,c.width,c.height);
    const d=x.getImageData(0,0,c.width,c.height).data; let sum=0,n=d.length/4;
    for (let i=0;i<d.length;i+=4) sum+=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    return sum/n;
  }
  function updateQuality(){
    const f=focusScore(), br=brightnessScore();
    let state='bad';
    if (f>35 && br>35 && br<230) state='good';
    else if (f>20 && br>25 && br<245) state='mid';
    stageWrap.className = state;
    if (state==='good') statusEl.textContent='‚úÖ Enfocado y buena luz';
    else if (state==='mid') statusEl.textContent='üü° Ajusta un poco (enfoque/luz)';
    else statusEl.textContent='üî¥ Borroso o con reflejos';
  }

  // ---- C√°mara ----
  async function startCamera(){
    if (stream) return;
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} }
      });
      video.srcObject = stream;
      await video.play();
      running = true;
      statusEl.textContent='Vista previa B/N (horizontal). Captura hasta 2 im√°genes.';
      loop();
    }catch(e){ console.error(e); statusEl.textContent='‚ùå No se pudo iniciar la c√°mara'; }
  }
  function stopCamera(){
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    running=false;
  }
  function loop(){
    if (!running) return;
    drawBWHorizontal(video);
    updateQuality();
    requestAnimationFrame(loop);
  }

  // ---- Captura desde c√°mara (con antirrebote) ----
  async function captureFromCamera(){
    if (shootInProgress) return;
    shootInProgress = true; shootBtn.disabled = true;

    // Guardar ‚Äúlo que ves‚Äù como PNG
    const blob = await new Promise(res => stage.toBlob(res, 'image/png', 1));
    sources.push(blob);
    setCounter();

    if (sources.length >= 2){
      stopCamera();
      statusEl.textContent='üßä Capturas completas (2/2). Ya puedes leer OCR.';
    } else {
      statusEl.textContent='‚úÖ Captura guardada (1/2). Toma otra.';
    }

    shootInProgress = false; shootBtn.disabled = false;
  }

  // ---- Cargar desde dispositivo (usa mismo pipeline horizontal) ----
  fileInput.addEventListener('change', async e => {
    const f = e.target.files?.[0]; if (!f) return;
    stopCamera();
    const img = await createImageBitmap(f);
    lastImage = img;
    drawBWHorizontal(img);
    const blob = await new Promise(res => stage.toBlob(res,'image/png',1));
    sources.push(blob);
    setCounter();
    statusEl.textContent='üñºÔ∏è Imagen cargada (B/N). Puedes a√±adir otra o leer OCR.';
    fileInput.value = '';
  });

  // ---- Controles ----
  shootBtn.addEventListener('click', async () => {
    if (!stream) await startCamera();
    else await captureFromCamera();
  });
  contrast.addEventListener('input', () => { if (running) drawBWHorizontal(video); else if (lastImage) drawBWHorizontal(lastImage); });
  brightness.addEventListener('input', () => { if (running) drawBWHorizontal(video); else if (lastImage) drawBWHorizontal(lastImage); });

  // ---- OCR ----
  ocrBtn.addEventListener('click', async () => {
    if (!sources.length) return;
    out.value = `Procesando OCR (${sources.length} imagen${sources.length>1?'es':''})‚Ä¶`;
    fieldsEl.textContent = '';

    const worker = await Tesseract.createWorker('spa', 1, { logger: m => console.log(m) });
    const texts=[], parsed=[];
    for (let i=0;i<sources.length;i++){
      const { data } = await worker.recognize(sources[i]);
      const t = (data.text||'').trim();
      texts.push(t); parsed.push(parseDNI(t));
    }
    await worker.terminate();

    out.value = (sources.length===2) ? fuseText(texts) : texts[0];
    const fused = (sources.length===2) ? fuseParsed(parsed) : parsed[0];
    fieldsEl.textContent = JSON.stringify(fused, null, 2);
  });

  // ===== Parser y consenso (igual que antes) =====
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }
  function parseDNI(text){
    const clean = norm(text);
    const out = { "Nombre":"", "Apellidos":"", "Tipo documento":"DNI", "N¬∫ Documento":"", "Sexo":"", "Nacionalidad":"", "Fecha nacimiento":"" };
    const mDni = clean.match(/\b\d{8}[A-Z]\b/); if (mDni) out["N¬∫ Documento"]=mDni[0];
    const lines = clean.split(/\n| {2,}/);
    for (let i=0;i<lines.length;i++){ const l=lines[i];
      if (l.includes("APELLID")) out["Apellidos"]=(lines[i+1]||"").split(' ').slice(0,4).join(' ');
      if (l.includes("NOMBRE"))  out["Nombre"]  =(lines[i+1]||"").split(' ').slice(0,3).join(' ');
    }
    const mLine = clean.match(/\b[MF]\b.*?\b[A-Z]{3}\b.*?\b\d{1,2} \d{1,2} \d{4}\b/);
    if (mLine){ const parts=mLine[0].split(/\s+/);
      out["Sexo"]=parts[0];
      out["Nacionalidad"]=parts.find(p=>p.length===3&&/[A-Z]{3}/.test(p))||"";
      const f=mLine[0].match(/\d{1,2} \d{1,2} \d{4}/); if(f) out["Fecha nacimiento"]=f[0].replace(/\s/g,'/');
    }
    return out;
  }
  function fuseText(texts){
    const toks = texts.map(t=>t.split(/\s+/));
    const max = Math.max(...toks.map(a=>a.length)); const res=[];
    for (let i=0;i<max;i++){
      const col = toks.map(a=>a[i]).filter(Boolean);
      if (!col.length) continue;
      const m = majority(col); res.push(m||centroidString(col));
    }
    return res.join(' ');
  }
  function fuseParsed(list){
    const keys=Object.keys(list[0]); const res={};
    for (const k of keys){
      const vals = list.map(o=>(o[k]||'').trim()).filter(Boolean);
      if (!vals.length){ res[k]=''; continue; }
      const m = majority(vals); res[k] = m || centroidString(vals);
    }
    if (res["Apellidos"]) res["Apellidos"]=res["Apellidos"].replace(/\s{2,}/g,' ').trim();
    return res;
  }
  function majority(arr){ const map=new Map(); for(const v of arr) map.set(v,(map.get(v)||0)+1);
    let best=null,cnt=0; for(const [v,c] of map.entries()) if(c>cnt){cnt=c;best=v;}
    const ties=[...map.values()].filter(c=>c===cnt).length; return ties>1?null:best; }
  function centroidString(arr){ let best=null,score=Infinity;
    for(const a of arr){ let s=0; for(const b of arr){ s+=lev(a,b); } if(s<score){score=s;best=a;} }
    return best||arr[0]; }
  function lev(a,b){ const m=a.length,n=b.length,dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
    for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j;
    for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const c=a[i-1]===b[j-1]?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+c); } } return dp[m][n]; }
})();
</script>
</body>
</html>
