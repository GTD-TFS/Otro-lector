<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî Rectificaci√≥n + Orientaci√≥n + ROIs + Validaci√≥n</title>
<style>
  body{margin:0;background:#f6f7f9;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:980px;margin:0 auto;padding:1rem}
  .card{background:#fff;padding:1rem;border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06)}
  h1{margin:.25rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{margin-top:.75rem;display:flex;justify-content:center}
  label.btn{padding:.7rem 1rem;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  label.btn input{display:none}
  #status{margin-top:.6rem;text-align:center;color:#555;word-break:break-word}
  textarea{width:100%;min-height:140px;margin-top:.75rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-top:1rem}
  @media (max-width:800px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî Pro (web)</h1>

    <canvas id="stage"></canvas>
    <div id="status">Cargar imagen del dispositivo. Se rectifica, orienta y lee con precisi√≥n por zonas.</div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*">
      </label>
    </div>

    <div class="grid">
      <div>
        <h3>Texto OCR (orientaci√≥n elegida)</h3>
        <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>
      </div>
      <div>
        <h3>Campos (normalizados)</h3>
        <pre id="fields"></pre>
        <h3>Array exportaci√≥n</h3>
        <pre id="exportArr"></pre>
      </div>
    </div>
  </div>
</div>

<!-- OpenCV.js (para rectificaci√≥n y preprocesado) -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="cv['onRuntimeInitialized']=()=>{window.__cvReady=true}"></script>
<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

<script>
(() => {
  const stage = document.getElementById('stage');
  const sctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = document.getElementById('status');
  const fileInput = document.getElementById('file');
  const out = document.getElementById('out');
  const fieldsEl = document.getElementById('fields');
  const exportEl = document.getElementById('exportArr');

  const OUT_W = 1800, OUT_H = 1012; // 16:9 grande para buena nitidez
  stage.width = OUT_W; stage.height = OUT_H;

  // ==== Utilidades canvas ====
  function bmpToCanvas(bmp){
    const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height;
    c.getContext('2d').drawImage(bmp,0,0); return c;
  }
  function ensureLandscapeCanvas(c){
    if (c.height > c.width){
      const o=document.createElement('canvas'); o.width=c.height; o.height=c.width;
      const x=o.getContext('2d'); x.translate(o.width/2,o.height/2); x.rotate(Math.PI/2); x.drawImage(c, -c.width/2,-c.height/2);
      return o;
    }
    return c;
  }
  function drawToStage(src){
    sctx.clearRect(0,0,OUT_W,OUT_H);
    // cover 16:9
    const sw=src.width, sh=src.height, tr=OUT_W/OUT_H, sr=sw/sh;
    let sx,sy,cw,ch;
    if (sr>tr){ ch=sh; cw=Math.round(sh*tr); sx=Math.round((sw-cw)/2); sy=0; }
    else { cw=sw; ch=Math.round(sw/tr); sx=0; sy=Math.round((sh-ch)/2); }
    sctx.drawImage(src, sx,sy,cw,ch, 0,0,OUT_W,OUT_H);
    // devuelve canvas base 16:9
    const base=document.createElement('canvas'); base.width=OUT_W; base.height=OUT_H;
    base.getContext('2d').drawImage(stage,0,0);
    return base;
  }
  function rotateCanvas180(c){
    const o=document.createElement('canvas'); o.width=c.width; o.height=c.height;
    const x=o.getContext('2d'); x.translate(o.width,o.height); x.rotate(Math.PI); x.drawImage(c,0,0); return o;
  }
  function rotateCanvas90(c){
    const o=document.createElement('canvas'); o.width=c.height; o.height=c.width;
    const x=o.getContext('2d'); x.translate(o.width/2,o.height/2); x.rotate(Math.PI/2); x.drawImage(c,-c.width/2,-c.height/2); return o;
  }
  function rotateCanvas270(c){
    const o=document.createElement('canvas'); o.width=c.height; o.height=c.width;
    const x=o.getContext('2d'); x.translate(o.width/2,o.height/2); x.rotate(3*Math.PI/2); x.drawImage(c,-c.width/2,-c.height/2); return o;
  }

  // ==== OpenCV helpers ====
  function cvMatFromCanvas(c){ let src=cv.imread(c); return src; }
  function canvasFromCvMat(mat){ const c=document.createElement('canvas'); c.width=mat.cols; c.height=mat.rows; cv.imshow(c,mat); return c; }

  function warpByLargestQuad(colorC){
    if (!window.__cvReady) return null;
    const src=cvMatFromCanvas(colorC);
    const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
    const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
    const edges=new cv.Mat(); cv.Canny(blur,edges,50,150);

    const contours=new cv.MatVector(); const hierarchy=new cv.Mat();
    cv.findContours(edges,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

    let bestArea=0, best=null;
    for (let i=0;i<contours.size();i++){
      const cnt=contours.get(i);
      const peri=cv.arcLength(cnt,true);
      const approx=new cv.Mat();
      cv.approxPolyDP(cnt,approx,0.02*peri,true);
      if (approx.rows===4){
        const area=cv.contourArea(approx);
        if (area>bestArea){ bestArea=area; best=approx; }
      }
      approx.delete(); cnt.delete();
    }
    gray.delete(); blur.delete(); edges.delete(); hierarchy.delete();
    if (!best){ contours.delete(); src.delete(); return null; }

    // ordenar esquinas (top-left, top-right, bottom-right, bottom-left)
    const pts=[]; for(let i=0;i<4;i++){ pts.push(best.intPtr(i,0)); }
    // Convert to xy pairs
    const arr=[];
    for(let i=0;i<4;i++){ const p=best.data32S.slice(i*2,i*2+2); arr.push({x:p[0],y:p[1]}); }
    // ordenar por suma/resta
    arr.sort((a,b)=> (a.x+a.y)-(b.x+b.y)); // tl (min sum), br (max sum) quedan 0 y 3
    const [tl, maybeTr, maybeBl, br] = arr;
    const rem = [maybeTr, maybeBl].sort((a,b)=> a.x-b.x);
    const tr = rem[1], bl = rem[0];

    const dstW = OUT_W, dstH = OUT_H;
    const srcTri = cv.matFromArray(4,1,cv.CV_32FC2, [tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
    const dstTri = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, dstW,0, dstW,dstH, 0,dstH]);

    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const warped = new cv.Mat();
    cv.warpPerspective(src, warped, M, new cv.Size(dstW,dstH), cv.INTER_LINEAR, cv.BORDER_REPLICATE);

    // cleanup
    contours.delete(); best.delete(); srcTri.delete(); dstTri.delete(); src.delete(); M.delete();

    return canvasFromCvMat(warped);
  }

  function deskewIfNeeded(colorC){
    if (!window.__cvReady) return colorC;
    const src=cvMatFromCanvas(colorC);
    const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
    const edges=new cv.Mat(); cv.Canny(gray,edges,50,150);
    const lines=new cv.Mat();
    cv.HoughLines(edges,lines,1,Math.PI/180,200,0,0,0,Math.PI);
    let angle=0;
    for (let i=0;i<lines.rows;i++){
      const rho=lines.data32F[i*2], theta=lines.data32F[i*2+1];
      angle += (theta*180/Math.PI);
    }
    angle = lines.rows? (angle/lines.rows) : 0;
    // normalizar a -45..45
    angle = ((angle+90)%90)-45;
    const center = new cv.Point(src.cols/2, src.rows/2);
    const M = cv.getRotationMatrix2D(center, angle, 1.0);
    const rot = new cv.Mat(); cv.warpAffine(src, rot, M, new cv.Size(src.cols, src.rows), cv.INTER_LINEAR, cv.BORDER_REPLICATE);
    const outC = canvasFromCvMat(rot);
    // cleanup
    src.delete(); gray.delete(); edges.delete(); lines.delete(); rot.delete(); M.delete();
    return outC;
  }

  function preprocessStable(colorBase16x9){
    if (window.__cvReady){
      let src=cvMatFromCanvas(colorBase16x9);
      let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
      // adaptive threshold (Gauss) ~ Sauvola-lite
      let bin=new cv.Mat(); cv.adaptiveThreshold(gray,bin,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,31,10);
      // unsharp: blur+addWeighted
      let blur=new cv.Mat(); cv.GaussianBlur(bin,blur,new cv.Size(3,3),0);
      let sharp=new cv.Mat(); cv.addWeighted(bin,1.3,blur,-0.3,0,sharp);
      const outC = canvasFromCvMat(sharp);
      // cleanup
      src.delete(); gray.delete(); bin.delete(); blur.delete(); sharp.delete();
      return outC;
    } else {
      // Fallback simple en canvas
      const w=colorBase16x9.width, h=colorBase16x9.height;
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      const x=c.getContext('2d',{willReadFrequently:true});
      x.drawImage(colorBase16x9,0,0);
      let img=x.getImageData(0,0,w,h), d=img.data;
      // gris
      for(let i=0;i<d.length;i+=4){
        const g=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
        d[i]=d[i+1]=d[i+2]=g;
      }
      x.putImageData(img,0,0);
      // umbral simple (Otsu r√°pido)
      let hist=new Uint32Array(256), sum=0, N=w*h;
      for(let i=0;i<d.length;i+=4){ hist[d[i]|0]++; sum+=d[i]; }
      let sumB=0,wB=0,varMax=0,thr=127;
      for(let t=0, wF=0, mB=0, mF=0; t<256; t++){
        wB+=hist[t]; if(!wB)continue; wF=N-wB; if(!wF)break;
        sumB+=t*hist[t]; mB=sumB/wB; mF=(sum-sumB)/wF;
        const v=wB*wF*(mB-mF)*(mB-mF); if(v>varMax){varMax=v;thr=t;}
      }
      for(let i=0;i<d.length;i+=4){ const v=d[i]>thr?255:0; d[i]=d[i+1]=d[i+2]=v; d[i+3]=255; }
      x.putImageData(img,0,0);
      return c;
    }
  }

  // ==== OCR helpers ====
  function createWorker(lang='spa'){ return Tesseract.createWorker(lang, 1, {}); }
  async function ocrCanvas(worker, canvas, params={}){
    await worker.setParameters({
      tessedit_pageseg_mode: params.psm ?? 6,
      preserve_interword_spaces: '1',
      user_defined_dpi: '300',
      tessedit_char_whitelist: params.whitelist ?? undefined
    });
    const blob = await new Promise(res => canvas.toBlob(res,'image/png',0.92));
    const { data } = await worker.recognize(blob);
    return data; // { text, words, ... }
  }

  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }

  function scoreTextForOrientation(t){
    const T=norm(t); const keys=["NOMBRE","APELLID","SEXO","NACIONAL","ESP","DNI","SOPORT","VALIDEZ","NACIM"];
    let s=0; for(const k of keys){ if(T.includes(k)) s++; }
    if (/\b\d{8}[A-Z]\b/.test(T)) s+=2;
    if (/\b\d{1,2}[\/.\-\s]\d{1,2}[\/.\-\s]\d{4}\b/.test(T)) s+=1;
    return s;
  }

  function findFirstWord(words, pattern){
    const re = (pattern instanceof RegExp)?pattern:new RegExp("\\b"+pattern+"\\b","i");
    for (const w of words||[]){
      const txt=(w.text||""); if (re.test(txt)) return w;
    }
    return null;
  }

  function roiAround(y, opts){ // y en coords de imagen binaria elegida
    const padY = Math.floor(OUT_H*(opts.padY ?? 0.10));
    const top = Math.max(0, y - padY);
    const height = Math.min(OUT_H - top, Math.floor(OUT_H*(opts.h ?? 0.16)));
    const x = Math.floor(OUT_W*(opts.x ?? 0.05));
    const w = Math.floor(OUT_W*(opts.w ?? 0.90));
    return { x, y:top, w, h:height };
  }
  function cropCanvas(src, r){
    const c=document.createElement('canvas'); c.width=r.w|0; c.height=r.h|0;
    c.getContext('2d').drawImage(src, r.x|0,r.y|0,r.w|0,r.h|0, 0,0,c.width,c.height);
    return c;
  }

  // DNI checksum y normalizaciones
  function fixDNI(nif){
    const m = nif.match(/^(\d{8})([A-Z])$/); if (!m) return nif;
    const letters="TRWAGMYFPDXBNJZSQVHLCKE"; const num=parseInt(m[1],10);
    return m[1] + letters[num % 23];
  }

  function parseNameApellidos(fullText){
    const lines = norm(fullText).split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const idxN = lines.findIndex(l=>/\bNOMBRE\b/.test(l));
    let nombre="", apellidos="";
    if (idxN>=0){
      const same = lines[idxN].replace(/.*\bNOMBRE\b[:\- ]*/,'').trim();
      const next = (lines[idxN+1]||'').trim();
      const nm = chooseNameCandidate([same,next]); if (nm) nombre=nm;
      const upper = lines.slice(Math.max(0,idxN-3), idxN+1);
      apellidos = guessSurnames(upper);
    } else {
      const idxA = lines.findIndex(l=>/APELLID/.test(l));
      if (idxA>=0){
        const a1=(lines[idxA+1]||'').trim(), a2=(lines[idxA+2]||'').trim();
        apellidos=[cleanTokens(a1), cleanTokens(a2)].filter(Boolean).join(' ');
        const nm=chooseNameCandidate(lines.slice(idxA+1, idxA+4)); if (nm) nombre=nm;
      }
    }
    return { nombre, apellidos };
  }
  function cleanTokens(s){
    return (s||'').replace(/\b(NOMBRE|APELLIDOS?|SEXO|NACIONALIDAD|NACIMIENTO|EMISION|VALIDEZ|SOPORTE|DOCUMENTO|DNI|TITULAR)\b/g,'')
                   .replace(/[^A-Z√Å√â√ç√ì√ö√ú√ë\s\-']/g,' ').replace(/\s+/g,' ').trim();
  }
  function chooseNameCandidate(arr){
    for (const raw of arr){ const s=cleanTokens(raw||''); if(!s) continue;
      const toks=s.split(/\s+/).filter(t=>t.length>=2 && !/^\d+$/.test(t));
      if (!toks.length) continue; return toks.slice(0,3).join(' ');
    } return '';
  }
  function guessSurnames(lines){
    const c=[]; for(const L of lines){ const s=cleanTokens(L); if(!s) continue;
      const toks=s.split(/\s+/).filter(t=>t.length>=2 && !/^\d+$/.test(t));
      if (toks.length>=2) c.push(toks.slice(0,2).join(' ')); else if (toks.length===1) c.push(toks[0]);
    }
    return c.join(' ').split(/\s+/).slice(0,2).join(' ').trim();
  }

  function buildExportArray(data){
    const U = s => (s||'').toString();
    const domDisplay = data["DOMICILIO"] || "";
    return [
      ["Nombre", U(data["Nombre"])],
      ["Apellidos", U(data["APELLIDOS"])],
      ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
      ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
      ["Sexo", U(data["SEXO"])],
      ["Nacionalidad", U(data["NACIONALIDAD"])],
      ["Nombre de los Padres", U(data["Nombre de los Padres"])],
      ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
      ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
      ["Domicilio", U(domDisplay)],
    ];
  }

  // ===== Orientaci√≥n estable: 0/90/180/270 sobre MISMA binaria =====
  async function chooseOrientation(binBase){
    const variants = [
      {c:binBase, rot:0,   painter:()=>{ sctx.clearRect(0,0,OUT_W,OUT_H); sctx.drawImage(binBase,0,0); }},
      {c:rotateCanvas90(binBase), rot:90, painter:()=>{ sctx.clearRect(0,0,OUT_W,OUT_H); sctx.drawImage(rotateCanvas90(colorBaseShown),0,0); }},
      {c:rotateCanvas180(binBase), rot:180, painter:()=>{ sctx.clearRect(0,0,OUT_W,OUT_H); sctx.drawImage(rotateCanvas180(colorBaseShown),0,0); }},
      {c:rotateCanvas270(binBase), rot:270, painter:()=>{ sctx.clearRect(0,0,OUT_W,OUT_H); sctx.drawImage(rotateCanvas270(colorBaseShown),0,0); }},
    ];
    const worker = await createWorker('spa');
    await worker.setParameters({ tessedit_pageseg_mode:6, preserve_interword_spaces:'1', user_defined_dpi:'300' });

    let best = {score:-1, idx:0, text:'', words:[]};
    for (let i=0;i<variants.length;i++){
      const blob = await new Promise(res => variants[i].c.toBlob(res,'image/png',0.92));
      const { data } = await worker.recognize(blob);
      const t=(data.text||'').trim(); const sc=scoreTextForOrientation(t);
      if (sc>best.score){ best={score:sc, idx:i, text:t, words:data.words||[]}; }
    }
    await worker.terminate();
    // pinta en pantalla la orientaci√≥n elegida (versi√≥n color equivalente)
    variants[best.idx].painter();
    return { text:best.text, words:best.words, rot:variants[best.idx].rot };
  }

  // ===== OCR por ROI (fino) =====
  async function readFieldROI(binChosen, roi, kind){
    const sub = cropCanvas(binChosen, roi);
    const worker = await createWorker('spa');
    let psm=7, whitelist='';
    if (kind==='dni'){ whitelist='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; psm=7; }
    if (kind==='date'){ whitelist='0123456789/-. '; psm=7; }
    if (kind==='sex'){ whitelist='MF'; psm=10; }
    if (kind==='nat'){ whitelist='ABCDEFGHIJKLMNOPQRSTUVWXYZ √Å√â√ç√ì√ö√ú√ë'; psm=7; }
    const data = await ocrCanvas(worker, sub, { psm, whitelist });
    await worker.terminate();
    let tx=(data.text||'').trim();
    // limpieza y normalizaci√≥n por campo
    if (kind==='dni'){
      const j=tx.replace(/[^0-9A-Z]/g,''); const m=j.match(/\d{8}[A-Z]/); tx = m ? fixDNI(m[0]) : '';
    } else if (kind==='date'){
      tx = tx.replace(/[^0-9/.\-\s]/g,'');
      const fechas=[...tx.matchAll(/\b(\d{1,2})[\/.\-\s](\d{1,2})[\/.\-\s](\d{4})\b/g)];
      const now=new Date(); const thisYear=now.getFullYear(), minYear=thisYear-100;
      let ok=''; for(const f of fechas){ const d=parseInt(f[1],10), m=parseInt(f[2],10), y=parseInt(f[3],10);
        if (y>=minYear&&y<=thisYear&&d>=1&&d<=31&&m>=1&&m<=12){ ok=`${String(d).padStart(2,'0')}/${String(m).padStart(2,'0')}/${y}`; break; } }
      tx=ok;
    } else if (kind==='sex'){
      tx = /\bF\b/.test(tx) ? 'Femenino' : (/\bM\b/.test(tx) ? 'Masculino' : '');
    } else if (kind==='nat'){
      const N = norm(tx);
      tx = (/\bESP(A√ëA|A√ëOLA)?\b/.test(N) || /\bESP\b/.test(N)) ? 'Espa√±a' :
           (N.split(/\s+/).find(t=>t.length===3) || '');
    }
    return tx;
  }

  // ==== MAIN FLOW ====
  let colorBaseShown=null; // versi√≥n color 16:9 que ves (para espejo visual)

  async function loadFromFile(file){
    out.value=''; fieldsEl.textContent=''; exportEl.textContent='';
    statusEl.textContent='Cargando‚Ä¶';
    const bmp = await createImageBitmap(file);
    let color = bmpToCanvas(bmp);
    color = ensureLandscapeCanvas(color);

    // Rectificaci√≥n por cuadril√°tero (si OpenCV listo); fallback deskew; despu√©s recorte a 16:9
    let rect = null;
    if (window.__cvReady){
      rect = warpByLargestQuad(color);
      if (!rect) rect = deskewIfNeeded(color);
    } else {
      rect = color;
    }
    colorBaseShown = drawToStage(rect); // pinta y ajusta a OUT_W√óOUT_H (lo que ves)

    statusEl.textContent='Preprocesando‚Ä¶';
    const binBase = preprocessStable(colorBaseShown); // UNA vez (estable)

    statusEl.textContent='Eligiendo orientaci√≥n‚Ä¶';
    const { text:chosenText, words:chosenWords } = await chooseOrientation(binBase);
    out.value = chosenText;

    // ROIs por anclas (en coords de la orientaci√≥n elegida)
    // sexo / nacionalidad / fecha
    const anchorSex = findFirstWord(chosenWords, /SEXO/i);
    const anchorNat = findFirstWord(chosenWords, /NACIONAL/i);
    const anchorNac = findFirstWord(chosenWords, /NACIM/i);
    const roiSex = anchorSex ? roiAround(anchorSex.bbox.y0, {x:0.05,w:0.25,h:0.14,padY:0.08}) : {x:OUT_W*0.05,y:OUT_H*0.52,w:OUT_W*0.25,h:OUT_H*0.14};
    const roiNat = anchorNat ? roiAround(anchorNat.bbox.y0, {x:0.25,w:0.30,h:0.14,padY:0.08}) : {x:OUT_W*0.30,y:OUT_H*0.52,w:OUT_W*0.30,h:OUT_H*0.14};
    const roiDate= anchorNac ? roiAround(anchorNac.bbox.y0, {x:0.55,w:0.40,h:0.16,padY:0.08}) : {x:OUT_W*0.55,y:OUT_H*0.52,w:OUT_W*0.40,h:OUT_H*0.16};

    // DNI: cerca de ‚ÄúDNI‚Äù o ‚ÄúDOCUMENTO‚Äù; fallback arriba derecha
    const anchorDNI = findFirstWord(chosenWords, /\bDNI\b/i) || findFirstWord(chosenWords, /DOCUMENTO/i);
    const roiDni = anchorDNI ? roiAround(anchorDNI.bbox.y0, {x:0.55,w:0.40,h:0.18,padY:0.10}) : {x:OUT_W*0.55,y:OUT_H*0.18,w:OUT_W*0.40,h:OUT_H*0.18};

    statusEl.textContent='Leyendo campos por zonas‚Ä¶';
    const binChosenCanvas = document.createElement('canvas');
    binChosenCanvas.width = binBase.width; binChosenCanvas.height = binBase.height;
    binChosenCanvas.getContext('2d').drawImage(binBase,0,0); // binaria en orientaci√≥n elegida ya ‚Äúpintada‚Äù por chooseOrientation

    const dni  = await readFieldROI(binChosenCanvas, roiDni, 'dni');
    const date = await readFieldROI(binChosenCanvas, roiDate, 'date');
    const sex  = await readFieldROI(binChosenCanvas, roiSex, 'sex');
    const nat  = await readFieldROI(binChosenCanvas, roiNat, 'nat');

    // Nombre / Apellidos por texto plano + ancla "NOMBRE"
    const { nombre, apellidos } = parseNameApellidos(chosenText);

    const fields = {
      "Nombre": nombre || "",
      "APELLIDOS": apellidos || "",
      "TIPO DOCUMENTO": "DNI",
      "N¬∫DOCUMENTO": dni || "",
      "SEXO": sex || "",
      "NACIONALIDAD": nat || "",
      "Nombre de los Padres": "",
      "FECHA DE NACIMIENTO": date || "",
      "LUGAR DE NACIMIENTO": "",
      "DOMICILIO": ""
    };

    fieldsEl.textContent = JSON.stringify(fields, null, 2);
    exportEl.textContent = JSON.stringify(buildExportArray(fields), null, 2);
    statusEl.textContent='‚úÖ OCR completado.';
  }

  fileInput.addEventListener('change', async (e) => {
    const f=e.target.files?.[0]; if(!f) return;
    try{ await loadFromFile(f); } catch(err){ console.error(err); statusEl.textContent='‚ùå Error en OCR.'; }
    finally{ e.target.value=''; }
  });
})();
</script>
</body>
</html>
