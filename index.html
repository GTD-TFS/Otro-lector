<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OCR DNI ‚Äî 5 fotos en B/N con consenso</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  :root { --bg:#f6f7f9; --fg:#111; --card:#fff; }
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .card{background:var(--card);border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06);padding:1rem}
  h1{margin:.3rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;margin:.75rem 0}
  button,label.btn{padding:.65rem .9rem;border:none;border-radius:10px;cursor:pointer;background:#111;color:#fff;font-size:1rem}
  button:disabled{opacity:.55;cursor:not-allowed}
  #counter{margin:.25rem 0;text-align:center;color:#555}
  textarea{width:100%;min-height:160px;margin-top:.5rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
  input[type=range]{width:140px}
  .row{display:flex;gap:1rem;justify-content:center;color:#555}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî 5 fotos B/N (consenso)</h1>

    <canvas id="stage"></canvas>
    <div id="counter">0 / 5 fotos</div>

    <div class="row">
      <div>üåó Contraste: <input id="contrast" type="range" min="0.8" max="2.2" step="0.05" value="1.6"></div>
      <div>üü° Brillo: <input id="brightness" type="range" min="0.7" max="1.5" step="0.05" value="1.0"></div>
    </div>

    <div class="toolbar">
      <label class="btn">üì∑ Tomar foto
        <input id="take" type="file" accept="image/*" capture="environment" style="display:none">
      </label>
      <button id="rotate">‚Üª Rotar 90¬∞</button>
      <button id="undo">‚Ü©Ô∏è Deshacer √∫ltima</button>
      <button id="reset">üßπ Reiniciar lote</button>
      <button id="run" disabled>üìñ Ejecutar OCR (5)</button>
    </div>

    <h3>Texto fusionado</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (consenso)</h3>
    <pre id="fields"></pre>

    <h3>Textos individuales (debug)</h3>
    <pre id="debug"></pre>
  </div>
</div>

<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const stage = $('stage');
  const ctx = stage.getContext('2d', { willReadFrequently: true });

  const take = $('take');
  const rotateBtn = $('rotate');
  const undoBtn = $('undo');
  const resetBtn = $('reset');
  const runBtn = $('run');
  const out = $('out');
  const fieldsEl = $('fields');
  const debugEl = $('debug');
  const counter = $('counter');
  const contrast = $('contrast');
  const brightness = $('brightness');

  // Estado
  let angle = 0;               // 0/90/180/270
  let lastImage = null;        // ImageBitmap de la √∫ltima foto cargada (para volver a rotar si quieres)
  const lot = [];              // blobs en PNG procesados (B/N) listos para OCR, m√°x. 5

  // Canvas fijo 16:9 para verlo igual siempre
  function initCanvas(){ stage.width = 1600; stage.height = 900; }
  initCanvas(); window.addEventListener('resize', initCanvas);

  function setCounter(){
    counter.textContent = `${lot.length} / 5 fotos`;
    runBtn.disabled = lot.length !== 5;
  }

  function drawBW(img){
    // Dibujar ‚Äúcover‚Äù 16:9
    const sw = img.videoWidth || img.width;
    const sh = img.videoHeight || img.height;

    // Rotaci√≥n
    const tmp = document.createElement('canvas');
    let tw = sw, th = sh;
    if (angle % 180 !== 0){ tw = sh; th = sw; }
    tmp.width = tw; tmp.height = th;
    const tctx = tmp.getContext('2d');
    tctx.save();
    if (angle % 360 !== 0){
      tctx.translate(tw/2, th/2);
      tctx.rotate(angle * Math.PI/180);
      tctx.drawImage(img, -sw/2, -sh/2);
    } else {
      tctx.drawImage(img, 0, 0);
    }
    tctx.restore();

    // Recorte cover a 16:9
    const targetRatio = stage.width / stage.height;
    const srcRatio = tw / th;
    let sx, sy, cw, ch;
    if (srcRatio > targetRatio){
      ch = th; cw = Math.round(th * targetRatio);
      sx = Math.round((tw - cw)/2); sy = 0;
    } else {
      cw = tw; ch = Math.round(tw / targetRatio);
      sx = 0; sy = Math.round((th - ch)/2);
    }
    ctx.clearRect(0,0,stage.width,stage.height);
    ctx.drawImage(tmp, sx, sy, cw, ch, 0, 0, stage.width, stage.height);

    // B/N + contraste/brillo
    const imgData = ctx.getImageData(0,0,stage.width,stage.height);
    const d = imgData.data;
    const c = parseFloat(contrast.value);
    const b = parseFloat(brightness.value);
    for (let i=0;i<d.length;i+=4){
      let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      g = g * c * b;
      g = g < 0 ? 0 : g > 255 ? 255 : g;
      d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(imgData, 0, 0);
  }

  async function addFromFile(file){
    const img = await createImageBitmap(file);
    lastImage = img;
    drawBW(img);
    // guardamos el canvas actual como PNG para OCR (lo que ves es lo que lee)
    const blob = await new Promise(res => stage.toBlob(res, 'image/png', 1));
    lot.push(blob);
    setCounter();
  }

  // Controles
  take.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    if (lot.length >= 5){
      alert('Ya hay 5 fotos. Usa Reiniciar o Deshacer para cambiar.');
      take.value = '';
      return;
    }
    await addFromFile(f);
    take.value = '';
  });

  rotateBtn.addEventListener('click', async () => {
    angle = (angle + 90) % 360;
    if (lastImage) drawBW(lastImage);
  });

  undoBtn.addEventListener('click', () => {
    if (!lot.length) return;
    lot.pop();
    setCounter();
    // Si hay imagen previa, redibuja √∫ltima a√±adida si la ten√≠amos
    if (lastImage) drawBW(lastImage);
  });

  resetBtn.addEventListener('click', () => {
    lot.length = 0;
    setCounter();
    ctx.clearRect(0,0,stage.width,stage.height);
    lastImage = null; angle = 0; out.value=''; fieldsEl.textContent=''; debugEl.textContent='';
  });

  contrast.addEventListener('input', () => { if (lastImage) drawBW(lastImage); });
  brightness.addEventListener('input', () => { if (lastImage) drawBW(lastImage); });

  runBtn.addEventListener('click', async () => {
    if (lot.length !== 5) return;

    out.value = 'Procesando OCR (5 fotos)‚Ä¶';
    fieldsEl.textContent = ''; debugEl.textContent = '';

    const worker = await Tesseract.createWorker('spa', 1, { logger: m => console.log(m) });
    const texts = [];
    const parsed = [];

    for (let i=0;i<lot.length;i++){
      const { data } = await worker.recognize(lot[i]);
      const t = (data.text || '').trim();
      texts.push(t);
      parsed.push(parseDNI(t));
    }
    await worker.terminate();

    // Depuraci√≥n
    debugEl.textContent = texts.map((t,i)=>`--- Foto ${i+1} ---\n${t}`).join('\n\n');

    // Fusi√≥n por consenso
    const fusedText = fuseText(texts);
    out.value = fusedText;

    const fusedFields = fuseParsed(parsed);
    fieldsEl.textContent = JSON.stringify(fusedFields, null, 2);
  });

  // ======== Consenso de TEXTO completo (opcional) ========
  function fuseText(texts){
    // mayor√≠a por token: elige la opci√≥n m√°s repetida en cada posici√≥n
    const tokenized = texts.map(t => t.split(/\s+/));
    const maxLen = Math.max(...tokenized.map(a=>a.length));
    const res = [];
    for (let i=0;i<maxLen;i++){
      const col = tokenized.map(a=>a[i]).filter(Boolean);
      if (!col.length) continue;
      const m = majority(col);
      res.push(m || centroidString(col));
    }
    return res.join(' ');
  }

  // ======== Parser y Consenso de CAMPOS ========
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ')
    .trim().toUpperCase(); }

  function parseDNI(text){
    const clean = norm(text);
    const out = { "Nombre":"", "Apellidos":"", "Tipo documento":"DNI", "N¬∫ Documento":"", "Sexo":"", "Nacionalidad":"", "Fecha nacimiento":"" };

    const mDni = clean.match(/\b\d{8}[A-Z]\b/);
    if (mDni) out["N¬∫ Documento"] = mDni[0];

    const lines = clean.split(/\n| {2,}/);
    for (let i=0;i<lines.length;i++){
      const l = lines[i];
      if (l.includes("APELLID")) out["Apellidos"] = (lines[i+1]||"").split(' ').slice(0,4).join(' ');
      if (l.includes("NOMBRE"))  out["Nombre"]   = (lines[i+1]||"").split(' ').slice(0,3).join(' ');
    }

    const mLine = clean.match(/\b[MF]\b.*?\b[A-Z]{3}\b.*?\b\d{1,2} \d{1,2} \d{4}\b/);
    if (mLine) {
      const parts = mLine[0].split(/\s+/);
      out["Sexo"] = parts[0];
      out["Nacionalidad"] = parts.find(p => p.length===3 && /[A-Z]{3}/.test(p)) || "";
      const f = mLine[0].match(/\d{1,2} \d{1,2} \d{4}/);
      if (f) out["Fecha nacimiento"] = f[0].replace(/\s/g,'/');
    }
    return out;
  }

  function fuseParsed(list){
    if (!list.length) return {};
    const keys = Object.keys(list[0]);
    const res = {};
    for (const k of keys){
      const vals = list.map(o => (o[k]||'').trim()).filter(Boolean);
      if (!vals.length){ res[k]=''; continue; }
      const best = majority(vals);
      res[k] = best || centroidString(vals);
    }
    // Une dos apellidos si vienen separados
    if (res["Apellidos"]) {
      res["Apellidos"] = res["Apellidos"].replace(/\s{2,}/g,' ').trim();
    }
    return res;
  }

  function majority(arr){
    const map = new Map();
    for (const v of arr) map.set(v, (map.get(v)||0)+1);
    let best=null, cnt=0;
    for (const [v,c] of map.entries()) if (c>cnt){ cnt=c; best=v; }
    const ties = [...map.values()].filter(c=>c===cnt).length;
    return ties>1 ? null : best;
  }

  function centroidString(arr){
    let best=null, bestScore=Infinity;
    for (const a of arr){
      let sum=0; for (const b of arr) sum += lev(a,b);
      if (sum < bestScore){ bestScore=sum; best=a; }
    }
    return best || arr[0];
  }

  function lev(a,b){
    const m=a.length, n=b.length;
    const dp = Array.from({length:m+1},()=>Array(n+1).fill(0));
    for(let i=0;i<=m;i++) dp[i][0]=i;
    for(let j=0;j<=n;j++) dp[0][j]=j;
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        const c = a[i-1]===b[j-1] ? 0 : 1;
        dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+c);
      }
    }
    return dp[m][n];
  }
})();
</script>
</body>
</html>
