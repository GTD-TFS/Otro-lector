<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>FILIATRON</title>
  <style>
    :root{
      --bg:#0b1220; --fg:#e6eefc; --accent:#4da3ff;
      --card:rgba(255,255,255,.08); --border:rgba(255,255,255,.18);
      --green:#22c57b; --red:#ff5656;
    }
    *{box-sizing:border-box}
    body{
      margin:0;padding:20px;
      font-family:system-ui,"Segoe UI",Arial;
      color:var(--fg);
      /* Fondo con imagen (se gestiona con pseudo-elementos para asegurar visibilidad) */
      background:none;
      min-height:100dvh;
    }
    /* Capa de foto de fondo asegurada */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background:url('./aq.png') center / cover no-repeat;
      z-index:-2;
      transform:translateZ(0); /* fuerza pintar y evita glitches de backdrop-filter */
    }
    /* Velo oscuro encima de la foto (controla visibilidad del fondo) */
    body::after{
      content:"";
      position:fixed;
      inset:0;
      background:linear-gradient(180deg, rgba(11,18,32,.45), rgba(11,18,32,.50));
      z-index:-1;
      pointer-events:none;
    }
    h1{
      margin:0 0 14px;
      font-size:32px;
      line-height:1.1;
      letter-spacing:.6px;
      font-weight:800;
      background:linear-gradient(92deg, #e6eefc, #8fc8ff 45%, #4da3ff 80%);
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      text-shadow:0 1px 0 rgba(0,0,0,.25);
      text-align:center;               /* centrado */
    }
    .grid{display:grid;gap:16px;max-width:1100px;margin:0 auto} /* centrado del layout */
    .two{grid-template-columns:1fr}
    @media(min-width:900px){.two{grid-template-columns:1fr 1fr}}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
      backdrop-filter:blur(10px);
      box-shadow:0 10px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.07);
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center}
    .row.center{justify-content:center}                   /* centrado de botones */
    .btn{border:1px solid var(--accent);color:var(--fg);background:rgba(77,163,255,.15);padding:10px 14px;border-radius:12px;cursor:pointer}
    .btn.secondary{border-color:var(--border);background:rgba(255,255,255,.05)}
    /* Comparecencia GPT en morado */
    #gptComparecencia{
      border-color:#8a4dff !important;
      background:rgba(138,77,255,.12);
    }
    #gptComparecencia:hover{ box-shadow:0 6px 18px rgba(138,77,255,.25) }
    #gptComparecencia:focus{ outline:2px solid rgba(138,77,255,.45); outline-offset:2px }
    /* Broom button accent (orange) */
    #clearForm{
      border-color:#ff8c1a !important;
      background:rgba(255,140,26,.08);
    }
    #clearForm:hover{ box-shadow:0 0 0 3px rgba(255,140,26,.18) inset; }
    #clearForm:focus{ outline:2px solid rgba(255,140,26,.5); outline-offset:2px; }
    .fields{display:grid;gap:12px;grid-template-columns:1fr}
    @media(min-width:760px){.fields{grid-template-columns:1fr 1fr}}
    label{font-size:12px;margin-bottom:4px;color:#cfe0ff;display:block}
    input,select,textarea{
      width:100%;padding:10px;border-radius:12px;background:rgba(10,16,28,.28);
      color:var(--fg);border:1px solid var(--border);outline:none;transition:border-color .15s
    }
    textarea{min-height:120px;resize:vertical}
    input.valid,select.valid{border-color:var(--green)!important}
    input.invalid,select.invalid{border-color:var(--red)!important}
    .span2{grid-column:1/-1}
    .badge{padding:4px 8px;border-radius:9999px;background:rgba(255,255,255,.12);border:1px solid var(--border);font-size:12px}
    .badge{ box-shadow:0 2px 10px rgba(77,163,255,.12), inset 0 0 0 1px rgba(255,255,255,.05) }
    .btn:hover{ box-shadow:0 6px 18px rgba(77,163,255,.20) }
    .btn:focus{ outline:2px solid rgba(77,163,255,.45); outline-offset:2px }
    .grow{flex:1}
    ul.list{list-style:none;margin:0;padding:0;display:flex;flex-wrap:wrap;gap:8px}
    ul.list li{border:1px solid var(--border);border-radius:10px;padding:6px 10px;background:rgba(255,255,255,.06);font-size:12px}
    ul.list li button{margin-left:8px}

    /* Campo con duda (modo B, borde amarillo) */
    input.uncertain, select.uncertain, textarea.uncertain{
      border-color:#ffc107 !important;
      box-shadow:0 0 0 2px rgba(255,193,7,.18) inset;
    }
  </style>
  <link rel="preload" as="image" href="aq.png">
</head>
<body>
<h1>FILIATRON</h1>

<div class="grid two">
  <!-- ACCIONES -->
  <div class="card">
    <div class="row center">
      <button class="btn" id="readAnalyze">Integrar DNI</button>
      <button class="btn" id="gptComparecencia" title="Abrir Comparecencia GPT">Comparecencia GPT</button>
      <button class="btn secondary broom" id="clearForm" title="Limpiar formulario">🧹</button>
    </div>

    <div class="row center" style="margin-top:10px">
      <span class="badge">Filiaciones: <span id="countF">0</span></span>
      <ul class="list" id="listaF"></ul>
    </div>
  </div>

  <!-- COMPARECENCIA + CAMPOS -->
  <div class="card">
    <div class="fields">
      <div class="span2">
        <!-- Texto 'Comparecencia (DOC)' eliminado -->
        <div class="row center" style="margin:6px 0 8px 0">
          <button class="btn" id="integrarDoc">Integrar comparecencia</button>
        </div>
        <textarea id="Doc" placeholder="Pega aquí la comparecencia…"></textarea>
      </div>

      <!-- Ficha de filiación actual -->
      <div><label>Nombre</label><input id="Nombre"></div>
      <div><label>Apellidos (MAYÚSCULAS)</label><input id="Apellidos"></div>
      <div><label>Tipo de documento</label><input id="Tipo"></div>
      <div><label>Nº documento</label><input id="Numero"></div>
      <div><label>Sexo</label>
        <select id="Sexo"><option></option><option>MASCULINO</option><option>FEMENINO</option></select>
      </div>
      <div><label>Nacionalidad</label><input id="Nacionalidad"></div>
      <div class="span2"><label>Nombre de los Padres</label><input id="Padres"></div>
      <div><label>Fecha de nacimiento</label><input id="Nacimiento"></div>
      <div><label>Lugar de nacimiento</label><input id="Lugar"></div>
      <div class="span2"><label>Domicilio</label><input id="Domicilio"></div>
      <div><label>Teléfono</label><input id="Telefono" inputmode="numeric" pattern="[0-9 ]*"></div>
      <div><label>Condición (oblig.)</label>
        <select id="Condicion">
          <option></option><option>Requirente</option><option>Perjudicado</option>
          <option>Testigo</option><option>Identificado</option><option>Detenido</option>
        </select>
      </div>

      <div class="span2"></div>
      <div class="span2 row center" style="margin-top:6px">
        <button class="btn" id="addFiliacion">Agregar filiación al expediente</button>
        <button class="btn" id="download">Descargar proyecto</button>
      </div>
    </div>
  </div>
</div>

<script>
const expediente = { doc: "", filiaciones: [] };

const toLines = (txt) => (txt || "")
  .split(/\r?\n/)
  .map(s => s.trim())
  .filter(s => s.length > 0);

const tcase = s => (s||"").toLowerCase().replace(/\b([A-Za-zÁÉÍÓÚÜÑáéíóúüñ])/g,c=>c.toUpperCase());
const ucase = s => (s||"").toUpperCase();
const normalize = s => (s||"").normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase();
const noSpace = s => normalize(s).replace(/\s+/g,'');

// --- MUNICIPIOS: loader + matcher (JSON externo con fallback embebido) ------
const MUNICIPIOS_EMBED = [
  "MADRID","BARCELONA","VALENCIA","SEVILLA","ZARAGOZA","MALAGA","MURCIA",
  "PALMA","BILBAO","LAS PALMAS DE GRAN CANARIA","SANTA CRUZ DE TENERIFE",
  "SAN CRISTOBAL DE LA LAGUNA","TELDE","ARRECIFE","ARONA","ADEJE","GRANADILLA DE ABONA",
  "PUERTO DE LA CRUZ","LA OROTAVA","SANTA LUCIA DE TIRAJANA","ARUCAS","AGUIMES","MOYA","ICOD DE LOS VINOS",
  "LA LAGUNA","LAS PALMAS","SANTA CRUZ"
];
let MUNICIPIOS_SET = new Set(MUNICIPIOS_EMBED.map(x => normalize(String(x))));
let MUNICIPIOS_NOSPACE_MAP = new Map([...MUNICIPIOS_SET].map(m => [m.replace(/\s+/g,''), m]));

async function initMunicipios(){
  try{
    const res = await fetch('municipios.json');
    if (!res.ok) return; // embed si falla
    const arr = await res.json();
    if (Array.isArray(arr)) {
      MUNICIPIOS_SET = new Set(arr.map(x => normalize(String(x))));
      MUNICIPIOS_NOSPACE_MAP = new Map([...MUNICIPIOS_SET].map(m => [m.replace(/\s+/g,''), m]));
    }
  }catch{/* offline: usar embed */}
}

function normTextAtoZ(s){
  return (s||"").normalize('NFD').replace(/[\u0300-\u036f]/g,'').toUpperCase()
    .replace(/[^A-ZÑÁÉÍÓÚÜ\s-]/g,'').replace(/\s+/g,' ').trim();
}

// Distancia de edición (Damerau-Levenshtein) limitada a 2
function damerauLevenshtein(a,b,limit=2){
  a=a||""; b=b||""; if(a===b) return 0; if(!a||!b) return Math.min(limit+1, Math.max(a.length,b.length));
  const al=a.length, bl=b.length; if (Math.abs(al-bl)>limit) return limit+1;
  const dp=Array.from({length:al+1},()=>Array(bl+1).fill(0));
  for(let i=0;i<=al;i++) dp[i][0]=i; for(let j=0;j<=bl;j++) dp[0][j]=j;
  for(let i=1;i<=al;i++){
    let minRow=limit+1;
    for(let j=1;j<=bl;j++){
      const cost=a[i-1]===b[j-1]?0:1;
      let v=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
      if(i>1&&j>1&&a[i-1]===b[j-2]&&a[i-2]===b[j-1]) v=Math.min(v, dp[i-2][j-2]+1);
      dp[i][j]=v; if(v<minRow) minRow=v;
    }
    if(minRow>limit) return limit+1;
  }
  return dp[al][bl];
}

function matchMunicipio(raw){
  if (!MUNICIPIOS_SET || typeof MUNICIPIOS_SET.size==='undefined'){
    return {canon:normTextAtoZ(raw||''), approx:false, found:false};
  }
  if (!raw) return {canon:"", approx:false, found:false};
  const cand = normTextAtoZ(raw);
  const can  = normalize(cand);
  if (!MUNICIPIOS_SET.size) return {canon:cand, approx:false, found:false};
  if (MUNICIPIOS_SET.has(can)) return {canon:cand, approx:false, found:true};
  let best=null, bestD=3;
  for (const m of MUNICIPIOS_SET){
    const d = damerauLevenshtein(can, m, 2);
    if (d<bestD){ bestD=d; best=m; if (d===0) break; }
  }
  if (best!=null && bestD<=2){
    return {canon: best.replace(/\s+/g,' ').trim(), approx:true, found:true};
  }
  return {canon:cand, approx:false, found:false};
}

function matchMunicipioSuffixNS(ns){
  if (!ns) return null;
  if (!MUNICIPIOS_NOSPACE_MAP || !MUNICIPIOS_NOSPACE_MAP.size) return null;
  const maxLen = Math.min(32, ns.length);
  for (let len = maxLen; len >= 5; len--) {
    const sub = ns.slice(ns.length - len);
    const hit = MUNICIPIOS_NOSPACE_MAP.get(sub);
    if (hit) return { canon: hit, index: ns.length - len };
  }
  return null;
}
// ---------------------------------------------------------------------------
// --- PROVINCIAS: set y mapa sin espacios -----------------------------------
const PROVINCIAS = [
  "A CORUÑA","ÁLAVA","ALAVA","ALBACETE","ALICANTE","ALMERÍA","ALMERIA","ASTURIAS","ÁVILA","AVILA",
  "BADAJOZ","BARCELONA","BIZKAIA","VIZCAYA","BURGOS","CÁCERES","CACERES","CÁDIZ","CADIZ","CANTABRIA",
  "CASTELLÓN","CASTELLON","CIUDAD REAL","CÓRDOBA","CORDOBA","CUENCA","GIRONA","GERONA","GRANADA",
  "GUADALAJARA","GUIPÚZCOA","GUIPUZCOA","GIPUZKOA","HUELVA","HUESCA","ILLES BALEARS","ISLAS BALEARES",
  "JAÉN","JAEN","LA RIOJA","LAS PALMAS","LEÓN","LEON","LLEIDA","LUGO","MADRID","MÁLAGA","MALAGA",
  "MURCIA","NAVARRA","NAFARROA","OURENSE","ORENSE","PALENCIA","PONTEVEDRA","SALAMANCA",
  "SANTA CRUZ DE TENERIFE","SEGOVIA","SEVILLA","SORIA","TARRAGONA","TERUEL","TOLEDO",
  "VALENCIA","VALLADOLID","ZAMORA","ZARAGOZA","CEUTA","MELILLA"
].map(x => normalize(x));

let PROVINCIAS_SET = new Set(PROVINCIAS);
let PROVINCIAS_NOSPACE = new Map([...PROVINCIAS_SET].map(p => [p.replace(/\s+/g,''), p]));

// Devuelve la PRIMERA provincia que aparece en la cadena sin espacios `ns` a partir de `start`
function findProvinceAfter(ns, start=0){
  if (!ns || !PROVINCIAS_NOSPACE.size) return null;
  let best = null;
  for (const [pNS, canon] of PROVINCIAS_NOSPACE.entries()){
    const idx = ns.indexOf(pNS, start);
    if (idx !== -1){
      if (!best || idx < best.index || (idx === best.index && pNS.length > best.pNS.length)){
        best = { index: idx, canon, pNS };
      }
    }
  }
  return best; // {index, canon, pNS} o null
}
// ---------------------------------------------------------------------------

// --- NOMBRES: loader + validador (SOLO JSON externo, sin embed) -------------
let NOMBRES_SET = new Set();

async function initNombres(){
  try{
    const res = await fetch('nombres.json');
    if (!res.ok) return; // si no está, no valida pero no rompe
    const arr = await res.json();
    if (Array.isArray(arr)) {
      NOMBRES_SET = new Set(arr.map(x=>normalize(String(x))));
    }
  }catch{/* offline: sin nombres */}
}

function isNombre(raw){
  const tok = normalize(normTextAtoZ(raw));
  if (!tok) return {ok:false, approx:false};
  if (!NOMBRES_SET || !NOMBRES_SET.size) return {ok:false, approx:false};
  if (NOMBRES_SET.has(tok)) return {ok:true, approx:false};
  const limit = tok.length<=6 ? 1 : 2;
  let bestD=limit+1;
  for (const n of NOMBRES_SET){
    const d = damerauLevenshtein(tok, n, limit);
    if (d<bestD){ bestD=d; if (d===0) break; }
  }
  return {ok: bestD<=limit, approx: bestD<=limit};
}
// ---------------------------------------------------------------------------

async function readFromClipboard(){
  try{
    const txt = await navigator.clipboard.readText();
    return txt || "";
  }catch{
    const m = prompt("Pega manualmente el texto:");
    return m || "";
  }
}

function parseByRules(ocrRaw){
  // Normalización de detección: mayúsculas sin tildes + SIN ESPACIOS → única cadena NS
  const raw = ocrRaw || "";
  const lines = toLines(raw);
  const U = lines.map(normalize);
  const upRaw = normalize(raw);
  let NS = '';
  const NS_MAP = [];
  for (let i = 0; i < upRaw.length; i++){
    const ch = upRaw[i];
    if (/\s/.test(ch)) continue; // quitamos espacios
    NS += ch;
    NS_MAP.push(i); // posición correspondiente en raw/upRaw
  }

  // Encabezados tolerantes (comparación sin espacios)
  const RX_DOM_NS  = /^D[O0Q]M[IL1]C[ÇC][IL1][L1I][IO0Q]$/;
  const RX_LNAC_NS = /L[UÜV][G6][A4]RDE?N[ A]*A?C[IM1][IM1][E3][MN][T7][O0]/;
  const RX_HIJO_NS = /H[IJ1][J1][OA0](?:\/[A@])?DE/;

  const findHeaderLine = (rxNS) => {
    for (let i=0;i<U.length;i++){
      if (rxNS.test(noSpace(U[i]))) return i;
    }
    return -1;
  };

  const idxDOM  = findHeaderLine(RX_DOM_NS);
  const idxLUG  = findHeaderLine(RX_LNAC_NS);
  const idxHIJO = findHeaderLine(RX_HIJO_NS);
  const idxEQUIPO = U.findIndex(s => s.trim() === 'EQUIPO');

  // --- Anclajes globales para zonas (usados por LUGAR y PADRES)
  const S_ALL = NS; // alias
  const gStopIDESP = S_ALL.indexOf('IDESP');
  const gStopIOESP = S_ALL.indexOf('IOESP');
  const gStopLT    = S_ALL.indexOf('<');
  const gStopEQ    = S_ALL.indexOf('EQUIPO');
  const gStopsArr  = [gStopIDESP, gStopIOESP, gStopLT, gStopEQ].filter(i=>i!==-1);
  const gStop      = gStopsArr.length ? Math.min(...gStopsArr) : S_ALL.length;
  // Regla base PADRES: buscar el "DE" inmediatamente previo al bloque MRZ/EQUIPO
  const gParentsDE = (function(){
    const winStart = Math.max(0, gStop - 16); // ventana corta para capturar "...ADE"
    const pos = S_ALL.lastIndexOf('DE', gStop);
    return (pos >= winStart && pos !== -1) ? pos : -1;
  })();

  // DOMICILIO: desde "DOMICILIO" hasta provincia o anclaje siguiente
  let domicilio = ""; let domicilioUncertain = true;
  {
    const s = NS;
    const key = 'DOMICILIO';
    const iDom = s.indexOf(key);
    if (iDom !== -1){
      const start = iDom + key.length;
      const a1 = s.indexOf('LUGARDENACIMIENTO', start);
      const a1b = s.indexOf('LAGARDENACIMIENTO', start);
      const a2 = s.indexOf('EQUIPO', start);
      const a3 = s.indexOf('HIJO/ADE', start);
      const a3b = s.indexOf('HIJOADE', start);
      const a4 = s.indexOf('IDESP', start);
      const a5 = s.indexOf('IOESP', start);
      const a6 = s.indexOf('<', start);
      const candidates = [a1,a1b,a2,a3,a3b,a4,a5,a6].filter(i=>i!==-1);
      const pv = findProvinceAfter(s, start);
      const anchorEnd = candidates.length ? Math.min(...candidates) : s.length;
      const end = (pv && pv.index < anchorEnd) ? pv.index : anchorEnd;

      let domNS = s.slice(start, end).trim();
      const suf = matchMunicipioSuffixNS(domNS);
      if (suf) {
        const nsStart = start;
        const nsEndStreet = start + suf.index; // fin de la calle dentro de NS
        const rawStart = NS_MAP[nsStart] ?? 0;
        const rawEndStreet = (NS_MAP[nsEndStreet-1] ?? NS_MAP[NS_MAP.length-1]) + 1;
        let streetRaw = raw.slice(rawStart, rawEndStreet);
        streetRaw = streetRaw
          .replace(/\s*,\s*/g, ', ')
          .replace(/\.([A-Za-zÁÉÍÓÚÜÑ])/g, '. $1')
          .replace(/([A-Za-zÁÉÍÓÚÜÑ])(\d)/g, '$1 $2')
          .replace(/(\d)([A-Za-zÁÉÍÓÚÜÑ])/g, '$1 $2')
          .replace(/\s{2,}/g,' ')
          .trim();
        domicilio = streetRaw + ', ' + suf.canon;
        domicilioUncertain = false;
      } else {
        // sin municipio detectable: devolver el trozo original con espaciado mínimo (en duda)
        const rawStart = NS_MAP[start] ?? 0;
        const rawEnd = (NS_MAP[end-1] ?? NS_MAP[NS_MAP.length-1]) + 1;
        let streetRaw = raw.slice(rawStart, rawEnd)
          .replace(/\s*,\s*/g, ', ')
          .replace(/\.([A-Za-zÁÉÍÓÚÜÑ])/g, '. $1')
          .replace(/\s{2,}/g,' ')
          .trim();
        domicilio = streetRaw;
      }
    }
  }

  // LUGAR DE NACIMIENTO: tras LUGARDENACIMIENTO/LAGARDENACIMIENTO hasta provincia o DE (padres)
  let lugarNac = ""; let lugarUncertain = true;
  {
    const s = NS;
    const keys = ['LUGARDENACIMIENTO','LAGARDENACIMIENTO'];
    let iLug = -1, k = '';
    for (const kk of keys){ const ii = s.indexOf(kk); if (ii!==-1){ iLug=ii; k=kk; break; } }
    if (iLug !== -1){
      const start = iLug + k.length;
      const a1 = s.indexOf('HIJO/ADE', start);
      const a1b = s.indexOf('HIJOADE', start);
      const a2 = s.indexOf('IDESP', start);
      const a3 = s.indexOf('IOESP', start);
      const a4 = s.indexOf('<', start);
      const a5 = s.indexOf('DOMICILIO', start);
      const a6 = s.indexOf('EQUIPO', start);
      const candidates = [a1,a1b,a2,a3,a4,a5,a6].filter(i=>i!==-1);
      const pv = findProvinceAfter(s, start);
      const anchorEnd = candidates.length ? Math.min(...candidates) : s.length;
      const parentsLimit = (gParentsDE !== -1 && gParentsDE > start) ? gParentsDE : Infinity;
      const hardEnd = Math.min(anchorEnd, parentsLimit);
      const end = (pv && pv.index < hardEnd) ? pv.index : hardEnd;

      let seg = s.slice(start, end);

      // corta números basura si se colaron
      const cutNum = seg.search(/[0-9]/);
      if (cutNum !== -1) seg = seg.slice(0, cutNum);

      const rawMunNS = seg.trim();                 // municipio en NS (pegado)
      const munMatch = matchMunicipio(rawMunNS);   // intenta canonizar municipio

      if (pv){ // hay provincia detectada
        // con provincia detectada bajamos incertidumbre
        lugarUncertain = false;

        const provCanon = tcase(pv.canon);
        const munCanon = munMatch.found ? tcase(munMatch.canon) : tcase(rawMunNS);

        if (!rawMunNS || normalize(munCanon) === normalize(pv.canon)){
          // Caso MADRIDMADRID o municipio vacío: no duplicar
          lugarNac = provCanon;
        } else {
          // Caso ALCOBENDASMADRID: mapea "Alcobendas, Madrid"
          lugarNac = `${munCanon}, ${provCanon}`;
        }
      } else {
        // Sin provincia detectada: comportamiento previo + mantiene incertidumbre salvo match exacto
        const rawLoc = rawMunNS;
        const mloc = matchMunicipio(rawLoc);
        lugarNac = mloc.found ? tcase(mloc.canon) : tcase(rawLoc);
        if (!(mloc && mloc.found && !mloc.approx)) lugarUncertain = true;
      }
    }
  }

  // PADRES (una sola línea): base "DE ... IDESP"; extrae 2 nombres con librería
  let padres = "";
  {
    const s = NS;
    const stop = gStop; // hasta IDESP/IOESP/< o EQUIPO
    let start = -1;
    let padresUncertain = true;

    // Regla base: usar el "DE" detectado justo antes del bloque MRZ/EQUIPO
    if (gParentsDE !== -1) start = gParentsDE + 2; // tras 'DE'

    // Si no hay gParentsDE, intenta regex de HIJO/ADE como respaldo
    if (start === -1){
      const rxHijo = /H[IJ1][J1][OA0](?:\/[A@])?DE/;
      const mH = rxHijo.exec(s);
      if (mH && (mH.index + mH[0].length) < stop){
        start = mH.index + mH[0].length;
      }
    }

    if (start !== -1 && start < stop){
      let seg = s.slice(start, stop);
      // eliminar números colados
      const cutNum = seg.search(/[0-9]/);
      if (cutNum !== -1) seg = seg.slice(0, cutNum);

      // limpiar separadores “OCR”
      seg = seg.replace(/[\/_|!¡]+/g, ' ').replace(/[,.;:]+/g, ' ');

      // Heurística clave: probar cortes en 'I' como separador (la '/' suele leerse como 'I')
      function pickTwoNamesFromCompact(compact){
        const clean = compact.replace(/\s+/g,'');
        let best = null;
        // a) Primero, splits en 'I'
        for (let j=1;j<clean.length-1;j++){
          if (clean[j] !== 'I') continue;
          const left = clean.slice(0,j);
          const right = clean.slice(j+1);
          const a = isNombre(left), b = isNombre(right);
          if (a && a.ok && b && b.ok){
            best = [left, right];
            break;
          }
        }
        // b) Si no hubo éxito, probar splits generales buscando dos nombres válidos
        if (!best){
          for (let i=2;i<=clean.length-2;i++){
            const left = clean.slice(0,i);
            const right = clean.slice(i);
            const a = isNombre(left);
            if (!(a && a.ok)) continue;
            let bestRight = null;
            for (let k=right.length; k>=2; k--){
              const cand = right.slice(0,k);
              const b = isNombre(cand);
              if (b && b.ok){ bestRight = cand; break; }
            }
            if (bestRight){
              best = [left, bestRight];
              break;
            }
          }
        }
        return best;
      }

      const pair = pickTwoNamesFromCompact(seg);
      if (pair){
        padresUncertain = false; // separación clara por 'I' o split válido
        padres = `${tcase(pair[0])} y ${tcase(pair[1])}`;
      } else {
        // Fallback mejorado: separar posibles compuestos pegados (p.ej. JOSELUIS)
        const rawTokens = seg.replace(/\s{2,}/g,' ').trim().split(/\s+/).filter(Boolean);
        function splitTwoNamesIfPossible(tok){
          const t = tok.replace(/[^A-ZÁÉÍÓÚÜÑ]/g,'');
          for (let i=2; i<=t.length-2; i++){
            const a = t.slice(0,i), b = t.slice(i);
            const ca = isNombre(a), cb = isNombre(b);
            if (ca && ca.ok && cb && cb.ok) return [a,b];
          }
          return null;
        }
        const tokens = [];
        for (const t of rawTokens){
          const split = splitTwoNamesIfPossible(t);
          if (split) tokens.push(...split); else tokens.push(t);
        }
        let chosen = [];
        for (let i=0; i<tokens.length && chosen.length<2; i++){
          const w = tokens[i];
          const chk = isNombre(w);
          if (chk && chk.ok) chosen.push(w);
        }
        padres = chosen.length===2 ? `${tcase(chosen[0])} y ${tcase(chosen[1])}` : seg;
      }
    }
  }

  // MRZ con separadores (método tradicional basado en “líneas” del raw)
  function detectMRZ(upperLines){
    const isSeparator = (s)=> /^([<\s0-9]){3,}$/.test((s||""));
    const clean = (s)=> (s||"").replace(/\s+/g,'').toUpperCase();
    const arr = upperLines.filter(s => s && s.trim() && !isSeparator(s));

    for(let i=0;i<arr.length;i++){
      const s = arr[i];
      if (/^I[DO]ESP/.test(s)){
        const l1 = clean(s), l2 = clean(arr[i+1]||""), l3 = clean(arr[i+2]||"");
        return [l1,l2,l3];
      }
    }
    const l2Pattern = /^([0-9A-Z]{2})([0-9A-Z]{2})([0-9A-Z]{2}).([MF])/;
    for(let j=0;j<arr.length;j++){
      const s = clean(arr[j]);
      if (l2Pattern.test(s)){
        const l1 = clean(arr[j-1]||""), l2 = s, l3 = clean(arr[j+1]||"");
        return [l1,l2,l3];
      }
    }
    const withAngles = arr.filter(s => (s||"").includes("<"));
    if (withAngles.length >= 3) return withAngles.slice(-3).map(clean);
    const last3Any = arr.slice(-3).map(clean);
    while (last3Any.length < 3) last3Any.unshift("");
    return last3Any;
  }

  // Fallback MRZ L3 desde NS (una sola línea): ESP → segundo “<<<” → L3
  function detectMRZ_L3_fromNS(ns){
    if(!ns) return "";
    const s = ns;
    const idxESP = s.indexOf("ESP");
    if (idxESP === -1) return "";
    const g1 = s.indexOf("<<<", idxESP + 3);
    if (g1 === -1) return "";
    const g2 = s.indexOf("<<<", g1 + 3);
    if (g2 === -1) return "";
    let start = g2 + 3;
    while (start < s.length && !/[A-ZÑ]/.test(s[start])) start++; // salta '0' u otros
    return s.slice(start);
  }

  // Obtener MRZ (L1/L2 desde método tradicional; L3 desde NS si falta)
  let [MRZ_L1, MRZ_L2, MRZ_L3] = detectMRZ(U);
  let mrzL3FromNS = false;
  if (!MRZ_L3 || MRZ_L3.length < 5){
    const l3ns = detectMRZ_L3_fromNS(NS);
    if (l3ns){ MRZ_L3 = l3ns; mrzL3FromNS = true; }
  }

  // Nacionalidad
  function isSpainFromL1(l1){
    const norm = l1.replace(/[1lİＩ]/g,'I').replace(/[5Ｓ]/g,'S').replace(/[0Ｏ]/g,'O');
    return /^I[DO]ESP/.test(norm);
  }
  let Nacionalidad = "";
  if (MRZ_L1 && isSpainFromL1(MRZ_L1)) Nacionalidad = "España";
  if (!Nacionalidad && MRZ_L2 && MRZ_L2.includes("ESP")) Nacionalidad = "España";

  // Nº documento
  function docFromL1(l1, l2){
    const m = l1.match(/<{3,}/);
    if (m){
      const idx = m.index;
      if (idx >= 9) return l1.slice(idx-9, idx).toUpperCase();
    }
    if (l2 && /^(<|<+)/.test(l2)){
      const clean = l1.replace(/</g,'');
      if (clean.length >= 9) return clean.slice(-9).toUpperCase();
    }
    return "";
  }
  let numDoc = MRZ_L1 ? docFromL1(MRZ_L1, MRZ_L2) : "";
  if (!numDoc && MRZ_L1){
    const mAlt = MRZ_L1.match(/([0-9]{8}[A-Z])/);
    if (mAlt) numDoc = mAlt[1].toUpperCase();
  }

  // Fecha (YYMMDD -> dd/mm/aaaa) y Sexo desde L2
  let fechaNac = "", sexo = "";
  {
    const mapDigit = (ch)=>{
      if (/[0-9]/.test(ch)) return ch;
      const t = ch.toUpperCase();
      if (t==='O' || t==='Q') return '0';
      if (t==='I' || t==='L') return '1';
      if (t==='Z') return '2';
      if (t==='S') return '5';
      if (t==='B') return '8';
      return '0';
    };
    const m = MRZ_L2 ? MRZ_L2.match(/^([0-9A-Z]{2})([0-9A-Z]{2})([0-9A-Z]{2}).([MF])/) : null;
    if (m) {
      const yy = parseInt(mapDigit(m[1][0]) + mapDigit(m[1][1]),10);
      const mm = mapDigit(m[2][0]) + mapDigit(m[2][1]);
      const dd = mapDigit(m[3][0]) + mapDigit(m[3][1]);
      const year = yy >= 30 ? 1900 + yy : 2000 + yy;
      fechaNac = `${dd}/${mm}/${year}`;
      sexo = m[4] === "F" ? "FEMENINO" : "MASCULINO";
    }
  }

  // Apellidos y Nombres desde L3
  let nombre = "", apellidos = "";
  if(MRZ_L3){
    const parts = MRZ_L3.split("<").filter(Boolean);
    const ap1 = parts[0] || "", ap2 = parts[1] || "";
    const nom1 = parts[2] || "", nom2 = parts[3] || "";
    apellidos = [ap1, ap2].filter(Boolean).join(" ").trim().toUpperCase();
    nombre = tcase([nom1, nom2].filter(Boolean).join(" ").trim());
  }
  let nombreUncertain = mrzL3FromNS;   // si vino del fallback desde NS, marcar amarillo
  let apellidosUncertain = mrzL3FromNS;

  // Tipo documento
  let tipo = "DNI";

  // Sanitización final
  const HEADER_RE = new RegExp(
    '^(?:'
      + 'D[O0Q]M[IL1N][CÇG][IL1][IL1][IO0Q]'
      + '|L[UÜV][G6][A4]R\\s*D[EE]?\\s*N[ A]*A?C[IM1][IM1][E3][MN][T7][O0]'
      + '|H[IJ1][J1][OA0](?:\\/[A@])?\\s*D[EE]'
    + ')[\\s:.-]*'
  , 'g');
  const sanitizeHeaderValue = (s)=>{
    if(!s) return '';
    const up = String(s).toUpperCase().replace(HEADER_RE, '');
    return up.replace(/^[\s:.,-]+|[\s:.,-]+$/g,'').replace(/\s{2,}/g,' ').trim();
  };
  const STRIP_EQUIPO_RE = /\bEQUIPO\b[:\s-]*/g;
  const stripEquipo = (s)=>{
    if(!s) return '';
    const up = String(s).toUpperCase().replace(STRIP_EQUIPO_RE, '');
    return up.replace(/^[\s:.,-]+|[\s:.,-]+$/g,'').replace(/\s{2,}/g,' ').trim();
  };

  // Aplicar limpieza
  let domicilioFin    = tcase(stripEquipo(sanitizeHeaderValue(domicilio)));
  let lugarNacFin     = tcase(stripEquipo(sanitizeHeaderValue(lugarNac)));
  let padresFin       = tcase(stripEquipo(sanitizeHeaderValue(padres))).replace(/\sY\s/g, ' y ');
  let nombreFin       = tcase(stripEquipo(nombre));
  let apellidosFin    = stripEquipo(apellidos).toUpperCase();
  let nacionalidadFin = stripEquipo(Nacionalidad);
  let tipoFin         = stripEquipo(tipo);
  let fechaNacFin     = stripEquipo(fechaNac);
  let sexoFin         = stripEquipo(sexo);
  let numDocFin       = stripEquipo(numDoc || "");

  const flags = {
    Nombre: !!nombreUncertain,
    Apellidos: !!apellidosUncertain,
    Padres: !!padresUncertain,
    Lugar: !!lugarUncertain,
    Domicilio: !!domicilioUncertain
  };

  return {
    Nombre: nombreFin,
    Apellidos: apellidosFin,
    "Tipo de documento": tipoFin,
    "Nº Documento": numDocFin,
    Sexo: sexoFin,
    Nacionalidad: nacionalidadFin,
    "Nombre de los Padres": padresFin,
    "Fecha de nacimiento": fechaNacFin,
    "Lugar de nacimiento": lugarNacFin,
    Domicilio: domicilioFin,
    _flags: flags
  };
}

function validateAll(){
  ["Nombre","Apellidos","Tipo","Numero","Sexo","Nacionalidad","Padres","Nacimiento","Lugar","Domicilio","Telefono","Condicion"]
    .forEach(id=>{
      const el=document.getElementById(id);
      const ok=!!(el.value&&el.value.trim());
      el.classList.toggle("valid",ok);
      el.classList.toggle("invalid",!ok);
    });
}
function updateCount(){
  document.getElementById('countF').textContent = String(expediente.filiaciones.length);
  renderLista();
}
function renderLista(){
  const ul = document.getElementById('listaF');
  ul.innerHTML = "";
  expediente.filiaciones.forEach((f,i)=>{
    const li = document.createElement('li');
    const label = `${i+1}. ${f.Apellidos || '(sin apellidos)'} ${f.Nombre ? ', '+f.Nombre : ''}`;
    li.textContent = label;
    const btn = document.createElement('button');
    btn.className = "btn secondary";
    btn.textContent = "Editar";
    btn.onclick = ()=> {
      fillFormFromParsed(f);
      ["Telefono","Condicion"].forEach(id=>{
        const el=document.getElementById(id);
        if (id==="Telefono" && f["Teléfono"]!=null) el.value = f["Teléfono"];
        if (id==="Condicion" && f["Condición"]!=null) el.value = f["Condición"];
      });
      expediente.filiaciones.splice(i,1);
      updateCount();
    };
    li.appendChild(btn);
    ul.appendChild(li);
  });
}
function updateFilename(){ /* ya no usamos apellidos para nombre */ }

function getFormAsFiliacion(){
  return {
    "Nombre": document.getElementById('Nombre').value,
    "Apellidos": (document.getElementById('Apellidos').value||"").toUpperCase(),
    "Tipo de documento": document.getElementById('Tipo').value,
    "Nº Documento": document.getElementById('Numero').value,
    "Sexo": document.getElementById('Sexo').value,
    "Nacionalidad": document.getElementById('Nacionalidad').value,
    "Nombre de los Padres": document.getElementById('Padres').value,
    "Fecha de nacimiento": document.getElementById('Nacimiento').value,
    "Lugar de nacimiento": document.getElementById('Lugar').value,
    "Domicilio": document.getElementById('Domicilio').value,
    "Teléfono": document.getElementById('Telefono').value,
    "Condición": document.getElementById('Condicion').value
  };
}
function fillFormFromParsed(p){
  if(p.Nombre!=null)  document.getElementById('Nombre').value = p.Nombre;
  if(p.Apellidos!=null) document.getElementById('Apellidos').value = p.Apellidos;
  if(p["Tipo de documento"]!=null) document.getElementById('Tipo').value = p["Tipo de documento"];
  if(p["Nº Documento"]!=null) document.getElementById('Numero').value = p["Nº Documento"];
  if(p.Sexo!=null) document.getElementById('Sexo').value = p.Sexo;
  if(p.Nacionalidad!=null) document.getElementById('Nacionalidad').value = p.Nacionalidad;
  if(p["Nombre de los Padres"]!=null) document.getElementById('Padres').value = p["Nombre de los Padres"];
  if(p["Fecha de nacimiento"]!=null) document.getElementById('Nacimiento').value = p["Fecha de nacimiento"];
  if(p["Lugar de nacimiento"]!=null) document.getElementById('Lugar').value = p["Lugar de nacimiento"];
  if(p.Domicilio!=null) document.getElementById('Domicilio').value = p.Domicilio;

  // marcar dudas (amarillo) según flags
  const idMap = {
    Nombre: 'Nombre',
    Apellidos: 'Apellidos',
    Padres: 'Padres',
    Lugar: 'Lugar',
    Domicilio: 'Domicilio'
  };
  // limpiar marcas anteriores
  for (const key in idMap){
    const el = document.getElementById(idMap[key]);
    if (el) el.classList.remove('uncertain');
  }
  if (p._flags){
    if (p._flags.Nombre) document.getElementById('Nombre')?.classList.add('uncertain');
    if (p._flags.Apellidos) document.getElementById('Apellidos')?.classList.add('uncertain');
    if (p._flags.Padres) document.getElementById('Padres')?.classList.add('uncertain');
    if (p._flags.Lugar) document.getElementById('Lugar')?.classList.add('uncertain');
    if (p._flags.Domicilio) document.getElementById('Domicilio')?.classList.add('uncertain');
  }

  validateAll();
}
// Limpia SOLO la UI (mantiene expediente)
function clearFormOnly(){
  ["Nombre","Apellidos","Tipo","Numero","Sexo","Nacionalidad","Padres","Nacimiento","Lugar","Domicilio","Telefono","Condicion"]
    .forEach(id=>{
      const el=document.getElementById(id);
      if (el){ el.value=""; el.classList.remove('uncertain'); }
    });
  const ta = document.getElementById('Doc');
  if (ta) ta.value = "";
  updateCount();
  validateAll();
}

function processOCR(ocr){
  if(!ocr.trim()){ alert("Portapapeles vacío. Copia el OCR primero."); return; }
  const parsed = parseByRules(ocr);
  fillFormFromParsed(parsed);
}

// Eventos
document.getElementById('readAnalyze').addEventListener('click', async ()=>{
  const ocr = await readFromClipboard();
  processOCR(ocr);
});

document.getElementById('gptComparecencia').addEventListener('click', ()=>{
  window.open('https://chatgpt.com/g/g-68fe060630348191b62c44416164a37d-comparecencia','_blank','noopener');
});

document.getElementById('integrarDoc').addEventListener('click', async ()=>{
  const txt = await readFromClipboard();
  if (!txt.trim()) { alert("Portapapeles vacío."); return; }
  document.getElementById('Doc').value = txt;
  expediente.doc = txt;
});

document.getElementById('addFiliacion').addEventListener('click', ()=>{
  const f = getFormAsFiliacion();
  const anyVal = Object.values(f).some(v => (v||"").trim()!=="");
  if (!anyVal){ alert("Ficha vacía."); return; }
  expediente.filiaciones.push(f);
  updateCount();
  clearFormOnly(); // vaciar para siguiente filiación (memoria intacta)
});

document.getElementById('clearForm').addEventListener('click', clearFormOnly);

document.getElementById('Doc').addEventListener('input', (e)=>{
  expediente.doc = e.target.value;
});

document.getElementById('download').addEventListener('click', ()=>{
  expediente.doc = document.getElementById('Doc').value || expediente.doc || "";

  if (expediente.filiaciones.length === 0){
    const f = getFormAsFiliacion();
    const anyVal = Object.values(f).some(v => (v||"").trim()!=="");
    if (anyVal) expediente.filiaciones.push(f);
  }

  const data = {
    doc: expediente.doc,
    filiaciones: expediente.filiaciones
  };

  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  const fname = `Proyecto ${pad(d.getHours())}-${pad(d.getMinutes())} ${pad(d.getDate())}_${pad(d.getMonth()+1)}_${d.getFullYear()}.json`;

  const a=document.createElement('a');
  a.href='data:application/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(data,null,2));
  a.download=fname; a.click();
});

// init
updateCount(); validateAll(); initMunicipios(); initNombres();
</script>

</body>
</html>
