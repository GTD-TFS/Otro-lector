<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî Conservador ‚Ä¢ Rectificaci√≥n + Orientaci√≥n + ROIs</title>
<style>
  :root{--bg:#f6f7f9;--card:#fff;--ink:#111;--muted:#667}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:980px;margin:0 auto;padding:1rem}
  .card{background:var(--card);padding:1rem;border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06)}
  h1{margin:.25rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{margin-top:.75rem;display:flex;justify-content:center}
  label.btn{padding:.7rem 1rem;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  label.btn input{display:none}
  #status{margin-top:.6rem;text-align:center;color:#555;word-break:break-word}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-top:1rem}
  @media (max-width:800px){ .grid{grid-template-columns:1fr} }
  textarea{width:100%;min-height:160px}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî Conservador</h1>

    <canvas id="stage"></canvas>
    <div id="status">Selecciona una imagen del dispositivo. Se rectifica (si hay OpenCV), se orienta y se leen campos con prudencia.</div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*"/>
      </label>
    </div>

    <div class="grid">
      <div>
        <h3>Texto (orientaci√≥n elegida)</h3>
        <textarea id="out" placeholder="Saldr√° aqu√≠ el texto OCR‚Ä¶"></textarea>
      </div>
      <div>
        <h3>Campos</h3>
        <pre id="fields"></pre>
        <h3>Array exportaci√≥n</h3>
        <pre id="exportArr"></pre>
      </div>
    </div>
  </div>
</div>

<!-- OpenCV.js (rectificaci√≥n). Si no carga a tiempo, continuamos sin romper -->
<script async src="https://cdn.jsdelivr.net/npm/opencv.js@4.10.0/opencv.js"
  onload="cv['onRuntimeInitialized']=()=>{window.__cvReady=true}" crossorigin="anonymous"></script>
<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

<script>
(() => {
  const stage = document.getElementById('stage');
  const sctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = document.getElementById('status');
  const fileInput = document.getElementById('file');
  const out = document.getElementById('out');
  const fieldsEl = document.getElementById('fields');
  const exportEl = document.getElementById('exportArr');

  const OUT_W = 1800, OUT_H = 1012; // 16:9 n√≠tido
  stage.width = OUT_W; stage.height = OUT_H;

  // === Helpers Canvas ===
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  async function waitCvReady(timeoutMs=8000){
    const t0=performance.now();
    while(!window.__cvReady){
      if(performance.now()-t0>timeoutMs) return false;
      await sleep(60);
    }
    return true;
  }
  function bmpToCanvas(bmp){ const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height; c.getContext('2d').drawImage(bmp,0,0); return c; }
  function ensureLandscape(c){
    if(c.height>c.width){
      const o=document.createElement('canvas'); o.width=c.height; o.height=c.width;
      const x=o.getContext('2d'); x.translate(o.width/2,o.height/2); x.rotate(Math.PI/2); x.drawImage(c,-c.width/2,-c.height/2); return o;
    }
    return c;
  }
  function drawCover16x9ToStage(src){
    sctx.clearRect(0,0,OUT_W,OUT_H);
    const sw=src.width, sh=src.height, tr=OUT_W/OUT_H, sr=sw/sh;
    let sx,sy,cw,ch;
    if(sr>tr){ ch=sh; cw=Math.round(sh*tr); sx=Math.round((sw-cw)/2); sy=0; }
    else { cw=sw; ch=Math.round(sw/tr); sx=0; sy=Math.round((sh-ch)/2); }
    sctx.drawImage(src, sx,sy,cw,ch, 0,0,OUT_W,OUT_H);
    const base=document.createElement('canvas'); base.width=OUT_W; base.height=OUT_H;
    base.getContext('2d').drawImage(stage,0,0);
    return base;
  }
  function rot90(c){ const o=document.createElement('canvas'); o.width=c.height; o.height=c.width; const x=o.getContext('2d'); x.translate(o.width/2,o.height/2); x.rotate(Math.PI/2); x.drawImage(c,-c.width/2,-c.height/2); return o; }
  function rot180(c){ const o=document.createElement('canvas'); o.width=c.width; o.height=c.height; const x=o.getContext('2d'); x.translate(o.width,o.height); x.rotate(Math.PI); x.drawImage(c,0,0); return o; }
  function rot270(c){ const o=document.createElement('canvas'); o.width=c.height; o.height=c.width; const x=o.getContext('2d'); x.translate(o.width/2,o.height/2); x.rotate(3*Math.PI/2); x.drawImage(c,-c.width/2,-c.height/2); return o; }
  function cropCanvas(src, r){ const c=document.createElement('canvas'); c.width=r.w|0; c.height=r.h|0; c.getContext('2d').drawImage(src, r.x|0,r.y|0,r.w|0,r.h|0, 0,0,c.width,c.height); return c; }

  // === OpenCV utils (rectificaci√≥n ligera) ===
  function cvMatFromCanvas(c){ return cv.imread(c); }
  function canvasFromMat(m){ const c=document.createElement('canvas'); c.width=m.cols; c.height=m.rows; cv.imshow(c,m); return c; }
  function warpByLargestQuad(colorC){
    try{
      const src=cvMatFromCanvas(colorC);
      const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
      const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
      const edges=new cv.Mat(); cv.Canny(blur,edges,50,150);

      const contours=new cv.MatVector(); const hierarchy=new cv.Mat();
      cv.findContours(edges,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

      let bestArea=0, best=null;
      for(let i=0;i<contours.size();i++){
        const cnt=contours.get(i);
        const peri=cv.arcLength(cnt,true);
        const approx=new cv.Mat();
        cv.approxPolyDP(cnt,approx,0.02*peri,true);
        if(approx.rows===4){
          const area=cv.contourArea(approx);
          if(area>bestArea){ bestArea=area; best=approx; }
        }
        approx.delete(); cnt.delete();
      }
      gray.delete(); blur.delete(); edges.delete(); hierarchy.delete();

      if(!best){ contours.delete(); src.delete(); return null; }

      const pts=[];
      for(let i=0;i<4;i++){ const p=best.data32S.slice(i*2,i*2+2); pts.push({x:p[0],y:p[1]}); }
      // ordenar esquinas por suma (tl) y resta (tr/bl)
      pts.sort((a,b)=>(a.x+a.y)-(b.x+b.y));
      const tl=pts[0], br=pts[3];
      const rest=[pts[1],pts[2]].sort((a,b)=>a.x-b.x);
      const bl=rest[0], tr=rest[1];

      const dstW=OUT_W, dstH=OUT_H;
      const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
      const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0, dstW,0, dstW,dstH, 0,dstH]);
      const M=cv.getPerspectiveTransform(srcTri,dstTri);
      const warped=new cv.Mat();
      cv.warpPerspective(src,warped,M,new cv.Size(dstW,dstH),cv.INTER_LINEAR,cv.BORDER_REPLICATE);

      contours.delete(); srcTri.delete(); dstTri.delete(); src.delete(); M.delete();
      return canvasFromMat(warped);
    }catch(_){ return null; }
  }

  // === Preprocesado conservador (una sola vez) ===
  function preprocessStable(color16x9){
    // Gris + adaptativeThreshold suave en OpenCV si est√° listo; si no, fallback m√≠nimo.
    if(window.__cvReady){
      const src=cvMatFromCanvas(color16x9);
      const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
      const bin=new cv.Mat(); cv.adaptiveThreshold(gray,bin,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,31,10);
      const outC=canvasFromMat(bin);
      src.delete(); gray.delete(); bin.delete();
      return outC;
    }else{
      const w=color16x9.width,h=color16x9.height;
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      const x=c.getContext('2d',{willReadFrequently:true});
      x.drawImage(color16x9,0,0);
      let img=x.getImageData(0,0,w,h), d=img.data;
      // gris
      for(let i=0;i<d.length;i+=4){ const g=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; d[i]=d[i+1]=d[i+2]=g; }
      x.putImageData(img,0,0);
      // umbral simple por histograma (conservador)
      let hist=new Uint32Array(256), sum=0, N=w*h;
      for(let i=0;i<d.length;i+=4){ hist[d[i]|0]++; sum+=d[i]; }
      let sumB=0,wB=0,varMax=0,thr=127;
      for(let t=0, wF=0, mB=0, mF=0; t<256; t++){
        wB+=hist[t]; if(!wB)continue; wF=N-wB; if(!wF)break;
        sumB+=t*hist[t]; mB=sumB/wB; mF=(sum-sumB)/wF;
        const v=wB*wF*(mB-mF)*(mB-mF); if(v>varMax){varMax=v;thr=t;}
      }
      for(let i=0;i<d.length;i+=4){ const v=d[i]>thr?255:0; d[i]=d[i+1]=d[i+2]=v; d[i+3]=255; }
      x.putImageData(img,0,0);
      return c;
    }
  }

  // === Tesseract helpers ===
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }
  function scoreText(t){
    const T=norm(t); const keys=["NOMBRE","APELLID","SEXO","NACIONAL","ESP","DNI","SOPORT","VALIDEZ","NACIM"];
    let s=0; for(const k of keys) if(T.includes(k)) s++;
    if(/\b\d{8}[A-Z]\b/.test(T)) s+=2;
    if(/\b\d{1,2}[\/.\-\s]\d{1,2}[\/.\-\s]\d{4}\b/.test(T)) s+=1;
    return s;
  }
  async function makeWorker(){
    const w=await Tesseract.createWorker('spa',1,{});
    await w.setParameters({ tessedit_pageseg_mode:6, preserve_interword_spaces:'1', user_defined_dpi:'300' });
    return w;
  }
  async function ocrCanvas(worker, canvas, params={}){
    await worker.setParameters({
      tessedit_pageseg_mode: params.psm ?? 6,
      tessedit_char_whitelist: params.whitelist ?? undefined,
      preserve_interword_spaces: '1',
      user_defined_dpi: '300'
    });
    const blob=await new Promise(r=>canvas.toBlob(r,'image/png',0.92));
    const { data }=await worker.recognize(blob);
    return data; // { text, words, lines, confidence, ... }
  }

  // === Orientaci√≥n estable 0/90/180/270 sobre la MISMA binaria ===
  async function chooseOrientation(binBase){
    const cands = [
      {rot:0, c:binBase},
      {rot:90, c:rot90(binBase)},
      {rot:180,c:rot180(binBase)},
      {rot:270,c:rot270(binBase)},
    ];
    const worker=await makeWorker();
    let best={idx:0,score:-1,text:'',words:[]};
    for(let i=0;i<cands.length;i++){
      const d=await ocrCanvas(worker,cands[i].c,{psm:6});
      const t=(d.text||'').trim(); const sc=scoreText(t);
      if(sc>best.score) best={idx:i,score:sc,text:t,words:d.words||[]};
    }
    await worker.terminate();
    return { rot:cands[best.idx].rot, text:best.text, words:best.words, binChosen:cands[best.idx].c };
  }

  // === ROIs por anclas ===
  function firstWord(words, regex){
    const r = (regex instanceof RegExp)?regex:new RegExp("\\b"+regex+"\\b","i");
    for(const w of words||[]){ if(r.test(w.text||'')) return w; }
    return null;
  }
  function roiBandAtY(y0,{x=0.05,w=0.90,h=0.16,padY=0.10}={}){
    const pad=Math.floor(OUT_H*padY);
    const top=Math.max(0,(y0|0)-pad);
    const hh=Math.min(OUT_H-top, Math.floor(OUT_H*h));
    const xx=Math.floor(OUT_W*x), ww=Math.floor(OUT_W*w);
    return {x:xx, y:top, w:ww, h:hh};
  }

  // === Normalizaciones ===
  function dniChecksum(nif){
    const m=nif.match(/^(\d{8})([A-Z])$/); if(!m) return '';
    const letters="TRWAGMYFPDXBNJZSQVHLCKE"; const num=parseInt(m[1],10);
    return m[1]+letters[num%23];
  }

  // === Lectura conservadora por ROI (whitelist + confianza) ===
  async function readFieldConservative(binChosen, roi, kind, confMin=70){
    const sub=cropCanvas(binChosen, roi);
    const worker=await makeWorker();
    let psm=7, whitelist='';
    if(kind==='dni'){ whitelist='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; psm=7; }
    if(kind==='date'){ whitelist='0123456789/-. '; psm=7; }
    if(kind==='sex'){ whitelist='MF'; psm=10; }
    if(kind==='nat'){ whitelist='ABCDEFGHIJKLMNOPQRSTUVWXYZ √Å√â√ç√ì√ö√ú√ë'; psm=7; }
    if(kind==='name'){ whitelist='ABCDEFGHIJKLMNOPQRSTUVWXYZ √Å√â√ç√ì√ö√ú√ë\'- '; psm=7; }

    const d=await ocrCanvas(worker, sub, {psm,whitelist});
    await worker.terminate();

    // Confianza conservadora: media de las palabras de la ROI
    const words=d.words||[];
    const avgConf = words.length ? words.reduce((a,w)=>a+(w.confidence||0),0)/words.length : (d.confidence||0);
    let txt=(d.text||'').trim();

    // Limpiezas por campo + validar confianza
    if(kind==='dni'){
      txt = txt.replace(/[^0-9A-Z]/g,'');
      const m = txt.match(/\d{8}[A-Z]/);
      if(!m || avgConf<confMin) return '';
      return dniChecksum(m[0]);
    }
    if(kind==='date'){
      txt = txt.replace(/[^0-9/.\-\s]/g,'');
      const fechas=[...txt.matchAll(/\b(\d{1,2})[\/.\-\s](\d{1,2})[\/.\-\s](\d{4})\b/g)];
      if(!fechas.length || avgConf<confMin) return '';
      const now=new Date(), Y=now.getFullYear(), Ymin=Y-100;
      for(const f of fechas){
        const d1=+f[1], m1=+f[2], y1=+f[3];
        if(y1>=Ymin && y1<=Y && d1>=1 && d1<=31 && m1>=1 && m1<=12){
          return `${String(d1).padStart(2,'0')}/${String(m1).padStart(2,'0')}/${y1}`;
        }
      }
      return '';
    }
    if(kind==='sex'){
      if(avgConf<confMin-10) return '';
      if(/\bF\b/.test(txt)) return 'Femenino';
      if(/\bM\b/.test(txt)) return 'Masculino';
      return '';
    }
    if(kind==='nat'){
      if(avgConf<confMin-5) return '';
      const N=norm(txt);
      if(/\bESP(A√ëA|A√ëOLA)?\b/.test(N) || /\bESP\b/.test(N)) return 'Espa√±a';
      const tri=(N.split(/\s+/).find(t=>t.length===3) || '');
      return tri || '';
    }
    if(kind==='name'){
      if(avgConf<confMin) return '';
      // devolvemos l√≠nea limpia (sin etiquetas)
      return txt.replace(/\b(NOMBRE|APELLIDOS?)\b/gi,'').trim();
    }
    return '';
  }

  // === Nombre/Apellidos por ancla (conservador: si no hay suficiente confianza, vac√≠o) ===
  function extractNameSurnamesConservative(fullText){
    const lines=norm(fullText).split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const idxN=lines.findIndex(l=>/\bNOMBRE\b/.test(l));
    let nombre='',apellidos='';
    if(idxN>=0){
      const same=lines[idxN].replace(/.*\bNOMBRE\b[:\- ]*/,'').trim();
      const next=(lines[idxN+1]||'').trim();
      const nm = chooseName([same,next]);
      if(nm.token && nm.token.length>=3 && nm.conf>=0.6) nombre=nm.token;
      const upper=lines.slice(Math.max(0,idxN-3),idxN+1);
      const ap = guessApellidos(upper);
      if(ap.token && ap.token.length>=3 && ap.conf>=0.6) apellidos=ap.token;
    }
    return {nombre, apellidos};
  }
  function cleanTokens(s){
    return (s||'').replace(/\b(NOMBRE|APELLIDOS?|SEXO|NACIONALIDAD|NACIMIENTO|EMISION|VALIDEZ|SOPORTE|DOCUMENTO|DNI|TITULAR)\b/gi,'')
                   .replace(/[^A-Z√Å√â√ç√ì√ö√ú√ë\s\-']/g,' ').replace(/\s+/g,' ').trim();
  }
  function chooseName(arr){
    // muy simple: coge la primera l√≠nea con 1‚Äì3 tokens >2 letras
    for(const raw of arr){
      const s=cleanTokens(raw); if(!s) continue;
      const toks=s.split(/\s+/).filter(t=>t.length>=2);
      if(!toks.length) continue;
      return { token:toks.slice(0,3).join(' '), conf:0.7 };
    }
    return {token:'', conf:0};
  }
  function guessApellidos(lines){
    const c=[];
    for(const L of lines){
      const s=cleanTokens(L); if(!s) continue;
      const toks=s.split(/\s+/).filter(t=>t.length>=2);
      if(toks.length>=2) c.push(toks.slice(0,2).join(' '));
      else if(toks.length===1) c.push(toks[0]);
    }
    const joined=c.join(' ').split(/\s+/).slice(0,2).join(' ').trim();
    return { token:joined, conf: joined?0.65:0 };
  }

  function buildExportArray(data){
    const U = s => (s||'').toString();
    const domDisplay = data["DOMICILIO"] || "";
    return [
      ["Nombre", U(data["Nombre"])],
      ["Apellidos", U(data["APELLIDOS"])],
      ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
      ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
      ["Sexo", U(data["SEXO"])],
      ["Nacionalidad", U(data["NACIONALIDAD"])],
      ["Nombre de los Padres", U(data["Nombre de los Padres"])],
      ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
      ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
      ["Domicilio", U(domDisplay)],
    ];
  }

  // === MAIN ===
  fileInput.addEventListener('change', async (e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    out.value=''; fieldsEl.textContent=''; exportEl.textContent='';
    try{
      statusEl.textContent='Cargando imagen‚Ä¶';
      const bmp=await createImageBitmap(f);
      let color=bmpToCanvas(bmp);
      color=ensureLandscape(color);

      // Rectificaci√≥n si OpenCV est√° listo
      const cvOk=await waitCvReady();
      if(cvOk){
        statusEl.textContent='Rectificando documento‚Ä¶';
        const warped=warpByLargestQuad(color);
        color = warped || color; // si falla, seguimos
      }

      // Ajustar a 16:9 de trabajo (y mostrar)
      const baseColor = drawCover16x9ToStage(color);

      statusEl.textContent='Preprocesando‚Ä¶';
      const binBase = preprocessStable(baseColor); // √∫nica

      statusEl.textContent='Orientando‚Ä¶';
      const { rot, text:chosenText, words:chosenWords, binChosen } = await chooseOrientation(binBase);
      // pintar color seg√∫n rot elegida
      let view = baseColor;
      if(rot===90) view=rot90(baseColor); else if(rot===180) view=rot180(baseColor); else if(rot===270) view=rot270(baseColor);
      sctx.clearRect(0,0,OUT_W,OUT_H); sctx.drawImage(view,0,0);

      out.value = chosenText;

      // ROIs conservadoras (si no hay ancla, fallback prudente)
      const aSex = firstWord(chosenWords,/SEXO/i);
      const aNat = firstWord(chosenWords,/NACIONAL/i);
      const aNac = firstWord(chosenWords,/NACIM/i);
      const aDNI = firstWord(chosenWords,/\bDNI\b/i) || firstWord(chosenWords,/DOCUMENTO/i);
      const aNom = firstWord(chosenWords,/NOMBRE/i);

      const roiSex = aSex ? roiBandAtY(aSex.bbox.y0,{x:0.05,w:0.22,h:0.14,padY:0.08}) : {x:OUT_W*0.05,y:OUT_H*0.55,w:OUT_W*0.22,h:OUT_H*0.12};
      const roiNat = aNat ? roiBandAtY(aNat.bbox.y0,{x:0.27,w:0.28,h:0.14,padY:0.08}) : {x:OUT_W*0.30,y:OUT_H*0.55,w:OUT_W*0.28,h:OUT_H*0.12};
      const roiDate= aNac ? roiBandAtY(aNac.bbox.y0,{x:0.55,w:0.40,h:0.16,padY:0.08}) : {x:OUT_W*0.55,y:OUT_H*0.55,w:OUT_W*0.40,h:OUT_H*0.14};
      const roiDni = aDNI ? roiBandAtY(aDNI.bbox.y0,{x:0.55,w:0.40,h:0.18,padY:0.10}) : {x:OUT_W*0.55,y:OUT_H*0.20,w:OUT_W*0.40,h:OUT_H*0.18};

      statusEl.textContent='Leyendo campos‚Ä¶';

      // Campos con umbrales (conservador)
      const dni  = await readFieldConservative(binChosen, roiDni,  'dni', 75);     // m√°s estricto
      const date = await readFieldConservative(binChosen, roiDate, 'date',70);
      const sex  = await readFieldConservative(binChosen, roiSex,  'sex', 65);
      const nat  = await readFieldConservative(binChosen, roiNat,  'nat', 65);

      // Nombre / Apellidos por texto plano, conservador (si duda, vac√≠o)
      let {nombre, apellidos} = extractNameSurnamesConservative(chosenText);

      const fields = {
        "Nombre": nombre || "",
        "APELLIDOS": apellidos || "",
        "TIPO DOCUMENTO": "DNI",
        "N¬∫DOCUMENTO": dni || "",
        "SEXO": sex || "",
        "NACIONALIDAD": nat || "",
        "Nombre de los Padres": "",
        "FECHA DE NACIMIENTO": date || "",
        "LUGAR DE NACIMIENTO": "",
        "DOMICILIO": ""
      };

      fieldsEl.textContent = JSON.stringify(fields, null, 2);
      exportEl.textContent = JSON.stringify(buildExportArray(fields), null, 2);
      statusEl.textContent='‚úÖ OCR conservador completado.';
    }catch(err){
      console.error(err);
      statusEl.textContent='‚ùå Error en OCR.';
    }finally{
      e.target.value='';
    }
  });
})();
</script>
</body>
</html>
