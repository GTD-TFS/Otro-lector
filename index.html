<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî Carga √∫nica, auto-OCR, campos b√°sicos</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  body{margin:0;background:#f6f7f9;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .card{background:#fff;padding:1rem;border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06)}
  h1{margin:.25rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{margin-top:.75rem;display:flex;justify-content:center}
  label.btn{padding:.7rem 1rem;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  label.btn input{display:none}
  #status{margin-top:.6rem;text-align:center;color:#555;word-break:break-word}
  textarea{width:100%;min-height:140px;margin-top:.75rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî Cargar imagen ‚Üí Auto</h1>

    <canvas id="stage"></canvas>
    <div id="status">Elige una foto del dispositivo. La normalizo a horizontal y lanzo OCR autom√°ticamente.</div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*">
      </label>
    </div>

    <h3>Texto OCR</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (normalizados)</h3>
    <pre id="fields"></pre>

    <h3>Array exportaci√≥n</h3>
    <pre id="exportArr"></pre>
  </div>
</div>

<!-- Tesseract -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const stage = document.getElementById('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = document.getElementById('status');
  const fileInput = document.getElementById('file');
  const out = document.getElementById('out');
  const fieldsEl = document.getElementById('fields');
  const exportEl = document.getElementById('exportArr');

  // Salida visible y para OCR: SIEMPRE horizontal 16:9
  const OUT_W = 1800, OUT_H = 1012; // un poco m√°s grande para letras m√°s n√≠tidas
  stage.width = OUT_W; stage.height = OUT_H;

  // --------- Carga & normalizaci√≥n a horizontal ---------
  async function loadFromFile(file){
    statusEl.textContent = 'Cargando imagen‚Ä¶';
    const bmp = await createImageBitmap(file); // la mayor√≠a de navegadores ya respetan EXIF

    // Normaliza a horizontal: si viene "alta>ancha", gira 90¬∞ a paisaje
    const sw = bmp.width, sh = bmp.height;
    const src = document.createElement('canvas');
    const sctx = src.getContext('2d');
    if (sh > sw) {
      src.width = sh; src.height = sw;
      sctx.translate(src.width/2, src.height/2);
      sctx.rotate(Math.PI/2);
      sctx.drawImage(bmp, -sw/2, -sh/2);
    } else {
      src.width = sw; src.height = sh;
      sctx.drawImage(bmp, 0, 0);
    }

    // Recorte COVER a 16:9 y pintar a canvas visible
    drawCover16x9To(stage, src);

    statusEl.textContent = '‚úÖ Imagen lista. Ejecutando OCR‚Ä¶';
    await doOCR(); // auto
  }

  function drawCover16x9To(targetCanvas, srcCanvas){
    const tw = targetCanvas.width, th = targetCanvas.height;
    const tctx = targetCanvas.getContext('2d');

    const sw = srcCanvas.width, sh = srcCanvas.height;
    const target = tw/th, ratio = sw/sh;
    let sx, sy, cw, ch;
    if (ratio > target) { ch = sh; cw = Math.round(sh * target); sx = Math.round((sw - cw)/2); sy = 0; }
    else { cw = sw; ch = Math.round(sw / target); sx = 0; sy = Math.round((sh - ch)/2); }

    tctx.clearRect(0,0,tw,th);
    tctx.drawImage(srcCanvas, sx, sy, cw, ch, 0, 0, tw, th);
  }

  // --------- Preprocesado ‚Äúfino‚Äù para OCR (auto) ---------
  function buildOCRInput(){
    // Copia del canvas visible ‚Üí B/N (Otsu) + unsharp leve
    const c = document.createElement('canvas');
    c.width = OUT_W; c.height = OUT_H;
    const x = c.getContext('2d', { willReadFrequently:true });
    x.drawImage(stage, 0, 0);

    // Gris
    let img = x.getImageData(0,0,OUT_W,OUT_H);
    let d = img.data;
    const gray = new Uint8ClampedArray(OUT_W*OUT_H);
    for (let i=0,j=0;i<d.length;i+=4,j++){
      gray[j] = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    }

    // Otsu threshold
    const thr = otsu(gray, OUT_W, OUT_H);
    for (let j=0,i=0;j<gray.length;j++,i+=4){
      const v = gray[j] > thr ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
    }
    x.putImageData(img,0,0);

    // Unsharp mask muy suave (3x3)
    unsharp(x, OUT_W, OUT_H);

    return c;
  }

  function otsu(gray, w, h){
    const hist = new Uint32Array(256);
    let sum = 0, total = gray.length;
    for (let i=0;i<total;i++){ hist[gray[i]]++; sum += gray[i]; }
    let sumB=0, wB=0, wF=0, mB=0, mF=0, varMax=0, threshold=127;
    for (let t=0;t<256;t++){
      wB += hist[t]; if (wB===0) continue;
      wF = total - wB; if (wF===0) break;
      sumB += t*hist[t];
      mB = sumB / wB;
      mF = (sum - sumB) / wF;
      const between = wB*wF*(mB-mF)*(mB-mF);
      if (between > varMax){ varMax = between; threshold = t; }
    }
    return threshold;
  }

  function unsharp(ctx, w, h){
    const src = ctx.getImageData(0,0,w,h);
    const dst = ctx.createImageData(w,h);
    const s = src.data, d = dst.data;
    // kernel sharpening: [0,-1,0; -1,5,-1; 0,-1,0]
    const idx = (x,y)=> (y*w + x) * 4;
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        let acc=0;
        const i = idx(x,y);
        acc += - s[idx(x, y-1)]; // up
        acc += - s[idx(x-1,y)];  // left
        acc += 5 * s[i];         // center
        acc += - s[idx(x+1,y)];  // right
        acc += - s[idx(x, y+1)]; // down
        const v = Math.max(0, Math.min(255, acc));
        d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
      }
    }
    ctx.putImageData(dst,0,0);
  }

  // --------- OCR + PARSER ---------
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }

  function parseFields(text){
    const clean = norm(text);
    const now = new Date(); const thisYear = now.getFullYear(); const minYear = thisYear - 100;

    const out = {
      "Nombre": "",
      "APELLIDOS": "",
      "TIPO DOCUMENTO": "DNI",
      "N¬∫DOCUMENTO": "",
      "SEXO": "",
      "NACIONALIDAD": "",
      "Nombre de los Padres": "",
      "FECHA DE NACIMIENTO": "",
      "LUGAR DE NACIMIENTO": "",
      "DOMICILIO": ""
    };

    // N¬∫ DOCUMENTO: 8 d√≠gitos + letra
    const mDni = clean.match(/\b\d{8}[A-Z]\b/);
    if (mDni) out["N¬∫DOCUMENTO"] = mDni[0];

    // FECHA DE NACIMIENTO: dd mm aaaa con a√±o [thisYear-100, thisYear]
    // Permitimos separadores espacios, /, ., -
    const fechas = [...clean.matchAll(/\b(\d{1,2})[\/\.\-\s](\d{1,2})[\/\.\-\s](\d{4})\b/g)];
    for (const f of fechas) {
      const d = parseInt(f[1],10), m = parseInt(f[2],10), y = parseInt(f[3],10);
      if (y>=minYear && y<=thisYear && d>=1 && d<=31 && m>=1 && m<=12) {
        const dd = String(d).padStart(2,'0'), mm = String(m).padStart(2,'0');
        out["FECHA DE NACIMIENTO"] = `${dd}/${mm}/${y}`;
        break;
      }
    }

    // SEXO: M/F ‚Üí Masculino/Femenino
    const mSex = clean.match(/\b([MF])\b/);
    if (mSex) out["SEXO"] = (mSex[1] === 'M') ? 'Masculino' : 'Femenino';

    // El resto (Nombre/Apellidos‚Ä¶) lo dejamos vac√≠o por ahora
    return out;
  }

  function buildExportArray(data){
    const U = s => (s||'').toString();
    const domDisplay = data["DOMICILIO"] || "";
    return [
      ["Nombre", U(data["Nombre"])],
      ["Apellidos", U(data["APELLIDOS"])],
      ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
      ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
      ["Sexo", U(data["SEXO"])],
      ["Nacionalidad", U(data["NACIONALIDAD"])],
      ["Nombre de los Padres", U(data["Nombre de los Padres"])],
      ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
      ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
      ["Domicilio", U(domDisplay)],
    ];
  }

  async function doOCR(){
    try{
      const inputCanvas = buildOCRInput();
      const blob = await new Promise(res => inputCanvas.toBlob(res,'image/png',1));

      const worker = await Tesseract.createWorker('spa', 1, {
        logger: m => console.log(m)
      });
      // PSM 6 suele ir bien para bloques uniformes
      await worker.setParameters({ tessedit_pageseg_mode: 6 });
      const { data } = await worker.recognize(blob);
      await worker.terminate();

      const text = (data.text || '').trim();
      out.value = text;

      const parsed = parseFields(text);
      fieldsEl.textContent = JSON.stringify(parsed, null, 2);
      exportEl.textContent = JSON.stringify(buildExportArray(parsed), null, 2);

      statusEl.textContent = '‚úÖ OCR completado.';
    } catch (err) {
      console.error(err);
      statusEl.textContent = '‚ùå Error durante OCR.';
    }
  }

  // --------- Eventos ---------
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    try { await loadFromFile(f); }
    catch(err){ console.error(err); statusEl.textContent='‚ùå Error cargando la imagen.'; }
    finally { e.target.value=''; }
  });
})();
</script>
</body>
</html>
