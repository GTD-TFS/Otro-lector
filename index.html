<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OCR DNI ‚Äì Un solo display (B/N, disparo, rotar)</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  :root { --bg:#f6f7f9; --fg:#111; --card:#fff; }
  html,body{background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .panel{background:var(--card); border-radius:14px; box-shadow:0 8px 34px rgba(0,0,0,.06); padding:1rem}
  .toolbar{display:flex; flex-wrap:wrap; gap:.5rem; justify-content:center; margin:.75rem 0}
  button,label.btn{padding:.65rem .9rem; border:none; border-radius:10px; cursor:pointer; background:#111; color:#fff; font-size:1rem}
  button:disabled{opacity:.55; cursor:not-allowed}
  #stageWrap{position:relative; margin:0 auto; max-width:720px; width:100%;}
  #stage{width:100%; aspect-ratio:16/9; background:#000; border-radius:12px; display:block}
  #status{position:absolute; bottom:8px; left:0; right:0; text-align:center; color:#fff; background:rgba(0,0,0,.45); padding:6px; border-radius:10px; font-size:.95rem}
  #meta{display:flex; justify-content:center; gap:1rem; margin-top:.25rem; color:#555; font-size:.9rem}
  textarea{width:100%; min-height:160px; margin-top:.5rem}
  pre{background:#f7f7f7; border-radius:10px; padding:.7rem; white-space:pre-wrap}
  input[type=range]{width:140px}
</style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h2 style="margin:.2rem 0 0 0">OCR DNI ‚Äì B/N + Disparo + Rotar</h2>

    <div id="stageWrap">
      <canvas id="stage"></canvas>
      <div id="status">Pulsa ‚ÄúIniciar c√°mara‚Äù</div>
    </div>

    <div id="meta">
      <div>üåó Contraste: <input id="contrast" type="range" min="0.8" max="2.2" step="0.05" value="1.6"></div>
      <div>üü° Brillo: <input id="brightness" type="range" min="0.7" max="1.5" step="0.05" value="1.0"></div>
    </div>

    <div class="toolbar">
      <button id="start">üé• Iniciar c√°mara</button>
      <button id="shoot" disabled>üì∏ Disparo / Reanudar</button>
      <button id="rotate" disabled>‚Üª Girar 90¬∞</button>
      <button id="ocr" disabled>üìñ OCR</button>
      <label class="btn">üñºÔ∏è Buscar imagen
        <input id="file" type="file" accept="image/*" style="display:none">
      </label>
      <button id="clear">üßπ Limpiar</button>
    </div>

    <h3>Salida OCR</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (b√°sico)</h3>
    <pre id="fields"></pre>
  </div>
</div>

<!-- Tesseract -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const els = (id) => document.getElementById(id);
  const stage = els('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = els('status');
  const startBtn = els('start');
  const shootBtn = els('shoot');
  const rotateBtn = els('rotate');
  const ocrBtn = els('ocr');
  const clearBtn = els('clear');
  const fileInput = els('file');
  const out = els('out');
  const fieldsEl = els('fields');
  const contrast = els('contrast');
  const brightness = els('brightness');

  // Estado
  let stream = null;
  let video = document.createElement('video');
  video.playsInline = true; video.muted = true; video.autoplay = true;
  let running = false;          // loop de pintado
  let frozen = false;           // display congelado tras disparo
  let angle = 0;                // 0, 90, 180, 270
  let lastFrameTime = 0;

  // Dimensiones canvas
  function fitCanvas() {
    // Mant√©n 16:9 l√≥gico; el CSS ya da el tama√±o visible.
    stage.width = 1600;
    stage.height = 900;
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // Filtros B/N + contraste/brillo
  function drawBWFrame(img, rotateDeg=0) {
    ctx.save();
    ctx.clearRect(0,0,stage.width,stage.height);

    // Rotar si procede (centrado)
    if (rotateDeg % 360 !== 0) {
      ctx.translate(stage.width/2, stage.height/2);
      ctx.rotate(rotateDeg * Math.PI/180);
      ctx.translate(-stage.width/2, -stage.height/2);
    }

    // Dibujar fuente "cover" a 16:9
    const sw = img.videoWidth || img.width;
    const sh = img.videoHeight || img.height;
    const targetRatio = stage.width / stage.height;
    const srcRatio = sw / sh;
    let sx, sy, cw, ch;
    if (srcRatio > targetRatio) { // recortar ancho
      ch = sh; cw = Math.round(sh * targetRatio);
      sx = Math.round((sw - cw)/2); sy = 0;
    } else { // recortar alto
      cw = sw; ch = Math.round(sw / targetRatio);
      sx = 0; sy = Math.round((sh - ch)/2);
    }
    ctx.drawImage(img, sx, sy, cw, ch, 0, 0, stage.width, stage.height);

    // B/N + contraste/brillo
    const imgData = ctx.getImageData(0,0,stage.width,stage.height);
    const d = imgData.data;
    const c = parseFloat(contrast.value);
    const b = parseFloat(brightness.value);
    for (let i=0;i<d.length;i+=4){
      let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];  // gris
      g = g * c * b;                                     // contraste/brillo
      g = Math.max(0, Math.min(255, g));
      d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(imgData, 0, 0);
    ctx.restore();
  }

  async function startCamera() {
    if (stream) return;
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height:{ ideal: 720 }, aspectRatio:{ ideal: 1.777 } }
      });
      video.srcObject = stream;
      await video.play();
      running = true; frozen = false; angle = 0;
      statusEl.textContent = 'En vivo (B/N). Pulsa üì∏ para congelar.';
      shootBtn.disabled = false; rotateBtn.disabled = false; ocrBtn.disabled = true;
      loop();
    } catch (e) {
      console.error(e);
      statusEl.textContent = '‚ùå No se pudo iniciar la c√°mara.';
    }
  }

  function stopCamera() {
    if (stream) { stream.getTracks().forEach(t=>t.stop()); stream = null; }
    running = false;
  }

  function loop(ts=0) {
    if (!running) return;
    // limitar a ~30 fps
    if (ts - lastFrameTime > 33) {
      drawBWFrame(video, angle);
      lastFrameTime = ts;
    }
    requestAnimationFrame(loop);
  }

  // Disparo: pausa/reanuda
  function toggleFreeze() {
    if (!stream && !frozen) return; // no hay nada
    frozen = !frozen;
    if (frozen) {
      running = false; // paramos el loop, se queda el √∫ltimo frame dibujado
      statusEl.textContent = 'üßä Congelado. Ajusta contraste/rotar y pulsa OCR o üì∏ para reanudar.';
      ocrBtn.disabled = false;
    } else {
      if (stream) {
        running = true;
        statusEl.textContent = 'En vivo (B/N). Pulsa üì∏ para congelar.';
        requestAnimationFrame(loop);
        ocrBtn.disabled = true;
      }
    }
  }

  function rotate90() {
    angle = (angle + 90) % 360;
    // Redibujar con la nueva rotaci√≥n
    if (frozen) {
      // si est√° congelado, re-renderizamos el propio canvas (no hay video)
      // Nada que ‚Äúleer‚Äù: simplemente deja el canvas como est√°; el OCR usar√° la rotaci√≥n guardada
      const img = new Image();
      img.onload = () => drawBWFrame(img, angle);
      img.src = stage.toDataURL('image/png');
    }
  }

  // OCR desde el canvas actual (tal cual lo ves)
  async function doOCR() {
    ocrBtn.disabled = true;
    statusEl.textContent = 'Procesando OCR‚Ä¶';
    out.value = ''; fieldsEl.textContent = '';

    const blob = await new Promise(res => stage.toBlob(res, 'image/png', 1));
    const worker = await Tesseract.createWorker('spa', 1, { logger: m => console.log(m) });
    const { data } = await worker.recognize(blob);
    await worker.terminate();

    out.value = (data.text || '').trim();
    const parsed = parseDNI(out.value);
    fieldsEl.textContent = JSON.stringify(parsed, null, 2);
    statusEl.textContent = '‚úÖ OCR listo';
  }

  // Parser muy b√°sico por etiquetas (mejoraremos luego)
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ')
    .trim().toUpperCase(); }
  function parseDNI(text){
    const clean = norm(text);
    const out = { "Nombre":"", "Apellidos":"", "Tipo documento":"DNI", "N¬∫ Documento":"", "Sexo":"", "Nacionalidad":"", "Fecha nacimiento":"" };
    const mDni = clean.match(/\b\d{8}[A-Z]\b/); if (mDni) out["N¬∫ Documento"] = mDni[0];
    const lines = clean.split(/\n| {2,}/);
    for (let i=0;i<lines.length;i++){
      const l = lines[i];
      if (l.includes("APELLID")) out["Apellidos"] = (lines[i+1]||"").split(' ').slice(0,4).join(' ');
      if (l.includes("NOMBRE"))  out["Nombre"]   = (lines[i+1]||"").split(' ').slice(0,3).join(' ');
    }
    const mLine = clean.match(/\b[MF]\b.*?\b[A-Z]{3}\b.*?\b\d{1,2} \d{1,2} \d{4}\b/);
    if (mLine) {
      const parts = mLine[0].split(/\s+/);
      out["Sexo"] = parts[0];
      out["Nacionalidad"] = parts.find(p => p.length===3 && /[A-Z]{3}/.test(p)) || "";
      const f = mLine[0].match(/\d{1,2} \d{1,2} \d{4}/);
      if (f) out["Fecha nacimiento"] = f[0].replace(/\s/g,'/');
    }
    return out;
  }

  // Cargar imagen del dispositivo al mismo display
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    stopCamera();
    const img = new Image();
    img.onload = () => {
      running = false; frozen = true; angle = 0;
      drawBWFrame(img, angle);
      statusEl.textContent = 'üñºÔ∏è Imagen cargada (B/N). Puedes rotar o hacer OCR.';
      shootBtn.disabled = false; rotateBtn.disabled = false; ocrBtn.disabled = false;
    };
    img.src = URL.createObjectURL(f);
  });

  // Controles
  startBtn.onclick = startCamera;
  shootBtn.onclick = toggleFreeze;
  rotateBtn.onclick = rotate90;
  ocrBtn.onclick = doOCR;
  clearBtn.onclick = () => {
    stopCamera();
    ctx.clearRect(0,0,stage.width,stage.height);
    out.value=''; fieldsEl.textContent='';
    statusEl.textContent='Pulsa ‚ÄúIniciar c√°mara‚Äù';
    shootBtn.disabled = true; rotateBtn.disabled = true; ocrBtn.disabled = true;
  };
  contrast.oninput = () => { if (running) drawBWFrame(video, angle); };
  brightness.oninput = () => { if (running) drawBWFrame(video, angle); };
})();
</script>
</body>
</html>
