<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OCR DNI ‚Äî Variantes por ROI + Consenso + Checksum</title>
<link rel="preconnect" href="https://unpkg.com">
<style>
  body{margin:0;background:#f6f7f9;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:960px;margin:0 auto;padding:1rem}
  .card{background:#fff;padding:1rem;border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06)}
  h1{margin:.25rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{margin-top:.75rem;display:flex;justify-content:center}
  label.btn{padding:.7rem 1rem;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  label.btn input{display:none}
  #status{margin-top:.6rem;text-align:center;color:#555;word-break:break-word}

  textarea{width:100%;min-height:140px;margin-top:.75rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>OCR DNI ‚Äî Auto (estable y fino)</h1>

    <canvas id="stage"></canvas>
    <div id="status">Elige una foto del dispositivo. Normaliza, auto-gira si hace falta y lee con variantes por ROI.</div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*">
      </label>
    </div>

    <h3>Texto OCR</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (normalizados)</h3>
    <pre id="fields"></pre>

    <h3>Array exportaci√≥n</h3>
    <pre id="exportArr"></pre>
  </div>
</div>

<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const stage = document.getElementById('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = document.getElementById('status');
  const fileInput = document.getElementById('file');
  const out = document.getElementById('out');
  const fieldsEl = document.getElementById('fields');
  const exportEl = document.getElementById('exportArr');

  // Canvas visible (y base de OCR) horizontal 16:9 grande
  const OUT_W = 1800, OUT_H = 1012; // 16:9
  stage.width = OUT_W; stage.height = OUT_H;

  // ===== Utilidades canvas =====
  function ensureLandscape(imgBitmap){
    const sw = imgBitmap.width, sh = imgBitmap.height;
    const c = document.createElement('canvas');
    const x = c.getContext('2d');
    if (sh > sw){
      c.width = sh; c.height = sw;
      x.translate(c.width/2, c.height/2);
      x.rotate(Math.PI/2);
      x.drawImage(imgBitmap, -sw/2, -sh/2);
    } else {
      c.width = sw; c.height = sh;
      x.drawImage(imgBitmap, 0, 0);
    }
    return c;
  }
  function cover16x9(srcCanvas, tw=OUT_W, th=OUT_H){
    const sw = srcCanvas.width, sh = srcCanvas.height;
    const target = tw/th, ratio = sw/sh;
    let sx, sy, cw, ch;
    if (ratio > target) { ch = sh; cw = Math.round(sh * target); sx = Math.round((sw - cw)/2); sy = 0; }
    else { cw = sw; ch = Math.round(sw / target); sx = 0; sy = Math.round((sh - ch)/2); }
    const c = document.createElement('canvas'); c.width = tw; c.height = th;
    c.getContext('2d').drawImage(srcCanvas, sx, sy, cw, ch, 0, 0, tw, th);
    return c;
  }
  function rotate180(srcCanvas){
    const c = document.createElement('canvas'); c.width = srcCanvas.width; c.height = srcCanvas.height;
    const x = c.getContext('2d');
    x.translate(c.width, c.height);
    x.rotate(Math.PI);
    x.drawImage(srcCanvas, 0, 0);
    return c;
  }

  // ===== Preprocesado estable (UNA vez): gris + Otsu + unsharp =====
  function preprocessStable(baseColor){
    const w = baseColor.width, h = baseColor.height;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const x = c.getContext('2d', { willReadFrequently:true });
    x.drawImage(baseColor, 0, 0);
    // gris
    let img = x.getImageData(0,0,w,h), d = img.data;
    const gray = new Uint8ClampedArray(w*h);
    for (let i=0,j=0;i<d.length;i+=4,j++) gray[j] = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    // otsu
    const thr = otsu(gray);
    for (let j=0,i=0;j<gray.length;j++,i+=4){
      const v = gray[j] > thr ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
    }
    x.putImageData(img,0,0);
    // unsharp
    unsharp(x, w, h);
    return c;
  }
  function otsu(gray){
    const hist = new Uint32Array(256);
    let sum = 0, total = gray.length;
    for (let i=0;i<total;i++){ hist[gray[i]]++; sum += gray[i]; }
    let sumB=0, wB=0, wF=0, mB=0, mF=0, varMax=0, threshold=127;
    for (let t=0;t<256;t++){
      wB += hist[t]; if (wB===0) continue;
      wF = total - wB; if (wF===0) break;
      sumB += t*hist[t];
      mB = sumB / wB; mF = (sum - sumB) / wF;
      const between = wB*wF*(mB-mF)*(mB-mF);
      if (between > varMax){ varMax = between; threshold = t; }
    }
    return threshold;
  }
  function unsharp(ctx, w, h){
    const src = ctx.getImageData(0,0,w,h), dst = ctx.createImageData(w,h);
    const s = src.data, d = dst.data, idx = (x,y)=> (y*w + x) * 4;
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        const i = idx(x,y), up=idx(x,y-1), left=idx(x-1,y), right=idx(x+1,y), down=idx(x,y+1);
        let v = - s[up] - s[left] + 5*s[i] - s[right] - s[down];
        v = v<0?0:(v>255?255:v);
        d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
      }
    }
    ctx.putImageData(dst,0,0);
  }

  // ===== OCR helpers =====
  function createWorker(lang='spa'){
    return Tesseract.createWorker(lang, 1, {});
  }
  async function ocrCanvas(worker, canvas, params={}){
    await worker.setParameters({
      tessedit_pageseg_mode: params.psm ?? 6,
      preserve_interword_spaces: '1',
      user_defined_dpi: '300',
      tessedit_char_whitelist: params.whitelist ?? undefined
    });
    const blob = await new Promise(res => canvas.toBlob(res,'image/png',0.92));
    const { data } = await worker.recognize(blob);
    return data; // { text, words, lines, confidence, ... }
  }

  // ===== Variantes geom√©tricas (sobre binaria estable) =====
  function cropCanvas(src, x,y,w,h){
    x=Math.max(0,Math.floor(x)); y=Math.max(0,Math.floor(y));
    w=Math.max(1,Math.floor(w)); h=Math.max(1,Math.floor(h));
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    c.getContext('2d').drawImage(src, x,y,w,h, 0,0,w,h);
    return c;
  }
  function rotateCanvas(src, deg){
    const rad = deg*Math.PI/180; const s=Math.sin(rad), c=Math.cos(rad);
    const w=src.width, h=src.height;
    const bbW = Math.abs(w*c) + Math.abs(h*s);
    const bbH = Math.abs(w*s) + Math.abs(h*c);
    const out = document.createElement('canvas'); out.width=bbW|0; out.height=bbH|0;
    const x = out.getContext('2d');
    x.translate(out.width/2, out.height/2);
    x.rotate(rad);
    x.drawImage(src, -w/2, -h/2);
    return out;
    }
  function scaleCanvas(src, factor){
    const out = document.createElement('canvas'); out.width=(src.width*factor)|0; out.height=(src.height*factor)|0;
    out.getContext('2d').drawImage(src,0,0,out.width,out.height);
    return out;
  }
  function generateVariants(roiCanvas){
    const variants = [];
    const angles = [0, -2, 2];
    const scales = [1.0, 1.05];
    const shifts = [{dx:0,dy:0},{dx:0.02,dy:0},{dx:-0.02,dy:0}];
    for (const a of angles){
      let r = a===0 ? roiCanvas : rotateCanvas(roiCanvas, a);
      for (const s of scales){
        let rs = s===1? r : scaleCanvas(r, s);
        for (const sh of shifts){
          const dx = (sh.dx*rs.width)|0, dy=(sh.dy*rs.height)|0;
          const x0 = Math.max(0, 0+dx), y0 = Math.max(0, 0+dy);
          const x1 = Math.min(rs.width, rs.width+dx);
          const y1 = Math.min(rs.height, rs.height+dy);
          const w = (x1-x0)|0, h=(y1-y0)|0;
          if (w>10 && h>10) variants.push(cropCanvas(rs, x0,y0,w,h));
        }
      }
    }
    return variants;
  }

  // ===== Saliencia por componentes conexos (en binaria) para filtrar manchas =====
  function salientMask(binCanvas){
    const w=binCanvas.width, h=binCanvas.height;
    const x = binCanvas.getContext('2d');
    const img = x.getImageData(0,0,w,h).data;
    const bin = new Uint8Array(w*h);
    for (let i=0,j=0;i<img.length;i+=4,j++) bin[j] = img[i]>127 ? 1 : 0;

    const labels = new Int32Array(w*h).fill(0);
    let current = 0;
    const comps = [];
    const stack = [];
    const inside = (xx,yy)=>xx>=0 && yy>=0 && xx<w && yy<h;

    for (let y=0;y<h;y++){
      for (let x0=0;x0<w;x0++){
        const idx=y*w+x0;
        if (!bin[idx] || labels[idx]) continue;
        current++;
        let minx=x0,maxx=x0,miny=y,maxy=y, area=0;
        stack.length=0; stack.push(idx); labels[idx]=current;
        while(stack.length){
          const i0=stack.pop(); area++;
          const xx=i0%w, yy=(i0/w)|0;
          if (xx<minx)minx=xx; if (xx>maxx)maxx=xx;
          if (yy<miny)miny=yy; if (yy>maxy)maxy=yy;
          // 8-conexi√≥n
          for (let dy=-1; dy<=1; dy++){
            for (let dx=-1; dx<=1; dx++){
              if (!dx && !dy) continue;
              const nx=xx+dx, ny=yy+dy;
              if (!inside(nx,ny)) continue;
              const ni=ny*w+nx;
              if (bin[ni] && !labels[ni]) { labels[ni]=current; stack.push(ni); }
            }
          }
        }
        const bw=maxx-minx+1, bh=maxy-miny+1, ar=bw*bh;
        const density = area/ar;
        // Filtrado heur√≠stico: tama√±o y densidad de trazo razonable
        if (area>=25 && bw>=2 && bh>=4 && density>=0.1 && density<=0.9){
          comps.push({ x:minx, y:miny, w:bw, h:bh, area, density });
        }
      }
    }
    return comps;
  }

  // ===== Texto utils =====
  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }
  function levenshtein(a,b){
    const m=a.length,n=b.length;
    const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
    for(let i=0;i<=m;i++) dp[i][0]=i;
    for(let j=0;j<=n;j++) dp[0][j]=j;
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        const c=a[i-1]===b[j-1]?0:1;
        dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+c);
      }
    }
    return dp[m][n];
  }
  function voteToken(tokens){
    // mayor√≠a + desempate por m√≠nima suma de Levenshtein
    const count = new Map();
    for (const t of tokens) count.set(t, (count.get(t)||0)+1);
    let best=null, bestC=0;
    for (const [t,c] of count.entries()){ if (c>bestC){ best=t; bestC=c; } }
    const ties = [...count.entries()].filter(([t,c])=>c===bestC).map(([t])=>t);
    if (ties.length===1) return ties[0];
    let bestSum=Infinity, winner=ties[0];
    for (const t of ties){
      let s=0; for (const u of tokens) s+=levenshtein(t,u);
      if (s<bestSum){ bestSum=s; winner=t; }
    }
    return winner;
  }

  // DNI checksum
  function fixDNI(nif){
    // expects pattern 8 digits + letter; if letter wrong, correct
    const m = nif.match(/^(\d{8})([A-Z])$/); if (!m) return nif;
    const letters = "TRWAGMYFPDXBNJZSQVHLCKE";
    const num = parseInt(m[1],10);
    const correct = letters[num % 23];
    return m[1] + correct;
  }

  // ===== Parser por texto plano (nombre/apellidos + reglas) =====
  function parseFlatFields(fullText){
    const clean = norm(fullText);
    const now = new Date(); const thisYear = now.getFullYear(); const minYear = thisYear - 100;

    const out = {
      "Nombre": "",
      "APELLIDOS": "",
      "TIPO DOCUMENTO": "DNI",
      "N¬∫DOCUMENTO": "",
      "SEXO": "",
      "NACIONALIDAD": "",
      "Nombre de los Padres": "",
      "FECHA DE NACIMIENTO": "",
      "LUGAR DE NACIMIENTO": "",
      "DOMICILIO": ""
    };

    // DNI
    const mDni = clean.match(/\b\d{8}[A-Z]\b/);
    if (mDni) out["N¬∫DOCUMENTO"] = fixDNI(mDni[0]);

    // Fecha
    const fechas=[...clean.matchAll(/\b(\d{1,2})[\/\.\-\s](\d{1,2})[\/\.\-\s](\d{4})\b/g)];
    for (const f of fechas){
      const d=parseInt(f[1],10), m=parseInt(f[2],10), y=parseInt(f[3],10);
      if (y>=minYear && y<=thisYear && d>=1 && d<=31 && m>=1 && m<=12){
        out["FECHA DE NACIMIENTO"]=`${String(d).padStart(2,'0')}/${String(m).padStart(2,'0')}/${y}`;
        break;
      }
    }

    // Sexo
    const mSex = clean.match(/\b([MF])\b/);
    if (mSex) out["SEXO"] = (mSex[1] === 'M') ? 'Masculino' : 'Femenino';

    // Nacionalidad
    if (/\bESP(A√ëA|A√ëOLA)?\b/.test(clean)) out["NACIONALIDAD"] = "Espa√±a";
    else {
      const n3 = clean.match(/\b[A-Z]{3}\b/);
      out["NACIONALIDAD"] = n3 ? (n3[0]==='ESP'?'Espa√±a':n3[0]) : "";
    }

    // Nombre/Apellidos por ancla ‚ÄúNOMBRE‚Äù
    const lines = clean.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const idxN = lines.findIndex(l=>/\bNOMBRE\b/.test(l));
    if (idxN>=0){
      const same = lines[idxN].replace(/.*\bNOMBRE\b[:\- ]*/,'').trim();
      const next = (lines[idxN+1]||'').trim();
      const nm = chooseNameCandidate([same,next]);
      if (nm) out["Nombre"]=nm;
      const upperBlock = lines.slice(Math.max(0,idxN-3), idxN+1);
      const ap = guessSurnames(upperBlock);
      if (ap) out["APELLIDOS"]=ap;
    } else {
      // fallback: APELLID
      const idxA = lines.findIndex(l=>/APELLID/.test(l));
      if (idxA>=0){
        const a1=(lines[idxA+1]||'').trim(), a2=(lines[idxA+2]||'').trim();
        const ap=[a1,a2].filter(Boolean).map(cleanTokens).join(' ').trim();
        if (ap) out["APELLIDOS"]=ap;
        const nm=chooseNameCandidate(lines.slice(idxA+1, idxA+4));
        if (nm) out["Nombre"]=nm;
      }
    }

    return out;
  }
  function cleanTokens(s){
    return s.replace(/\b(NOMBRE|APELLIDOS?|SEXO|NACIONALIDAD|NACIMIENTO|EMISION|VALIDEZ|SOPORTE|DOCUMENTO|DNI|TITULAR)\b/g,'')
            .replace(/[^A-Z√Å√â√ç√ì√ö√ú√ë\s\-']/g,' ')
            .replace(/\s+/g,' ')
            .trim();
  }
  function chooseNameCandidate(arr){
    for (const raw of arr){
      const s = cleanTokens(raw||''); if (!s) continue;
      const toks = s.split(/\s+/).filter(t=>t.length>=2 && !/^\d+$/.test(t));
      if (!toks.length) continue;
      return toks.slice(0,3).join(' ');
    }
    return '';
  }
  function guessSurnames(linesBlock){
    const candidates=[];
    for(const L of linesBlock){
      const s=cleanTokens(L); if(!s) continue;
      const toks=s.split(/\s+/).filter(t=>t.length>=2 && !/^\d+$/.test(t));
      if (toks.length>=2) candidates.push(toks.slice(0,2).join(' '));
      else if (toks.length===1) candidates.push(toks[0]);
    }
    const joined=candidates.join(' ').split(/\s+/).filter(Boolean);
    return joined.slice(0,2).join(' ').trim();
  }

  function buildExportArray(data){
    const U = s => (s||'').toString();
    const domDisplay = data["DOMICILIO"] || "";
    return [
      ["Nombre", U(data["Nombre"])],
      ["Apellidos", U(data["APELLIDOS"])],
      ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
      ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
      ["Sexo", U(data["SEXO"])],
      ["Nacionalidad", U(data["NACIONALIDAD"])],
      ["Nombre de los Padres", U(data["Nombre de los Padres"])],
      ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
      ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
      ["Domicilio", U(domDisplay)],
    ];
  }

  // ===== Orientaci√≥n estable: misma binaria para 0¬∞ y 180¬∞ =====
  function keywordScore(text){
    const T = norm(text);
    const keys = ["NOMBRE","APELLID","SEXO","NACIONALIDAD","ESP","DNI","SOPORT","VALIDEZ","NACIM"];
    let s=0; for(const k of keys) if (T.includes(k)) s++;
    if (/\b\d{8}[A-Z]\b/.test(T)) s+=2;
    if (/\b\d{1,2}[\/.\-\s]\d{1,2}[\/.\-\s]\d{4}\b/.test(T)) s+=1;
    return s;
  }

  async function orientationStableOCR(baseColor){
    // baseColor: color, horizontal 16:9 (lo pintamos tambi√©n en stage)
    const pre0 = preprocessStable(baseColor);      // binaria *√∫nica*
    const pre180 = rotate180(pre0);                // misma imagen, rotada

    const workerFast = await createWorker('spa');
    const d0 = await ocrCanvas(workerFast, pre0,  { psm:6 });
    const d180 = await ocrCanvas(workerFast, pre180, { psm:6 });
    await workerFast.terminate();

    const t0 = (d0.text||'').trim(), t180 = (d180.text||'').trim();
    const s0 = keywordScore(t0), s180 = keywordScore(t180);
    let chosenText = t0, chosenBin = pre0, shown = baseColor;

    if (s180 > s0){
      chosenText = t180;
      chosenBin = pre180;
      shown = rotate180(baseColor);
      ctx.clearRect(0,0,OUT_W,OUT_H); ctx.drawImage(shown,0,0);
      statusEl.textContent='‚Üª Girado 180¬∞ autom√°ticamente.';
    } else {
      ctx.clearRect(0,0,OUT_W,OUT_H); ctx.drawImage(baseColor,0,0);
      statusEl.textContent='‚úÖ Orientaci√≥n correcta.';
    }
    return { chosenText, chosenBin, words: d0.words || [] }; // words de 0¬∞ nos sirven para anclas
  }

  // ===== ROIs por ancla y refinado por variantes + saliencia =====
  function wordsToLines(words){
    // agrupa por y ~ (heur√≠stico)
    const lines = [];
    for (const w of words||[]){
      const y = w.baseline ? w.baseline.y0 : w.bbox? w.bbox.y0 : w.confidence>=0? w.y0 : 0;
      const text = (w.text||'').trim();
      if (!text) continue;
      lines.push({ y: w.bbox? w.bbox.y0 : y, x: w.bbox? w.bbox.x0 : 0, text, bbox: w.bbox });
    }
    lines.sort((a,b)=>a.y-b.y);
    return lines;
  }
  function findAnchorROI(words, key, expand={x:0.25,y:0.12}){
    // busca palabra ancla y genera ROI alrededor del rengl√≥n
    if (!words || !words.length) return null;
    const W = wordsToLines(words);
    const idx = W.findIndex(w => norm(w.text).includes(key));
    if (idx<0) return null;
    const rowY = W[idx].y;
    // ROI: banda de altura +/-12% y todo el ancho, luego se usar√° patr√≥n
    return { x: OUT_W*0.05, y: Math.max(0, rowY - OUT_H*expand.y), w: OUT_W*0.9, h: OUT_H*(expand.y*2+0.08) };
  }

  async function refineFieldByVariants(binCanvas, roi, kind){
    // recorta ROI de la binaria y genera variantes
    const sub = cropCanvas(binCanvas, roi.x, roi.y, roi.w, roi.h);
    const variants = generateVariants(sub);

    const worker = await createWorker('spa');
    const readings = [];

    // par√°metros por campo
    let whitelist='', psm=7, post = s=>s;
    if (kind==='dni'){ whitelist='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; psm=7; post=s=>s.replace(/[^0-9A-Z]/g,''); }
    if (kind==='date'){ whitelist='0123456789/-. '; psm=7; post=s=>s.replace(/[^0-9/.\-\s]/g,''); }
    if (kind==='sex'){ whitelist='MF'; psm=10; post=s=>s.replace(/[^MF]/g,''); }
    if (kind==='nat'){ whitelist='ABCDEFGHIJKLMNOPQRSTUVWXYZ '; psm=7; post=s=>s.replace(/[^A-Z\s]/g,''); }

    for (const v of variants){
      const data = await ocrCanvas(worker, v, { psm, whitelist });
      const raw = (data.text||'').trim();
      const cleaned = post(raw).trim();
      if (cleaned) readings.push(cleaned);
    }
    await worker.terminate();

    if (!readings.length) return '';

    // voto token + limpiezas finales por campo
    let token = voteToken(readings);
    if (kind==='dni'){
      // extraer 8 d√≠gitos + letra, validar y corregir
      const m = token.match(/\b\d{8}[A-Z]\b/);
      if (m) token = fixDNI(m[0]);
      else {
        // a veces separado: une y reintenta
        const j = token.replace(/\s+/g,'');
        const m2 = j.match(/\d{8}[A-Z]/);
        if (m2) token = fixDNI(m2[0]); else token='';
      }
    }
    if (kind==='date'){
      // normaliza primera fecha v√°lida
      const fechas=[...token.matchAll(/\b(\d{1,2})[\/\.\-\s](\d{1,2})[\/\.\-\s](\d{4})\b/g)];
      const now=new Date(), thisYear=now.getFullYear(), minYear=thisYear-100;
      let ok='';
      for (const f of fechas){
        const d=parseInt(f[1],10), m=parseInt(f[2],10), y=parseInt(f[3],10);
        if (y>=minYear && y<=thisYear && d>=1 && d<=31 && m>=1 && m<=12){
          ok=`${String(d).padStart(2,'0')}/${String(m).padStart(2,'0')}/${y}`; break;
        }
      }
      token=ok;
    }
    if (kind==='sex'){
      token = /F/.test(token) ? 'Femenino' : /M/.test(token) ? 'Masculino' : '';
    }
    if (kind==='nat'){
      token = /\bESP(A√ëA|A√ëOLA)?\b/.test(token) ? 'Espa√±a' : (/\bESP\b/.test(token)?'Espa√±a':(token.split(/\s+/).find(t=>t.length===3) || ''));
    }

    return token;
  }

  async function fullPipeline(baseColor){
    // 1) Orientaci√≥n estable (comparando misma binaria)
    const { chosenText, chosenBin, words } = await orientationStableOCR(baseColor);

    // 2) Anclas ‚Üí ROIs (si alguna no aparece, creamos fallback ROI gen√©rico)
    // DNI: suele estar visible; si no hay ancla, exploramos banda inferior
    const roiSex = findAnchorROI(words, 'SEXO') || {x:OUT_W*0.05,y:OUT_H*0.56,w:OUT_W*0.9,h:OUT_H*0.10};
    const roiNat = findAnchorROI(words, 'NACIONAL') || {x:OUT_W*0.20,y:OUT_H*0.56,w:OUT_W*0.75,h:OUT_H*0.10};
    const roiDate= findAnchorROI(words, 'NACIM')   || {x:OUT_W*0.40,y:OUT_H*0.56,w:OUT_W*0.55,h:OUT_H*0.12};
    // DNI ROI: cerca de ‚ÄúDNI‚Äù o ‚ÄúDOCUMENTO‚Äù o ‚ÄúNUM SOPORTE‚Äù; fallback: franja central-alta derecha
    let roiDni = findAnchorROI(words,'DNI') || findAnchorROI(words,'DOCUMENTO') || {x:OUT_W*0.55,y:OUT_H*0.20,w:OUT_W*0.40,h:OUT_H*0.18};

    // 3) Refinado por variantes + saliencia (sobre binaria)
    // (Saliencia se usa impl√≠citamente al binarizar; si quisieras, podr√≠as intersectar comp. conexos aqu√≠)
    const dni = await refineFieldByVariants(chosenBin, roiDni, 'dni');
    const fec = await refineFieldByVariants(chosenBin, roiDate, 'date');
    const sex = await refineFieldByVariants(chosenBin, roiSex, 'sex');
    const nat = await refineFieldByVariants(chosenBin, roiNat, 'nat');

    // 4) Nombre y Apellidos por ancla (del texto plano ya elegido)
    const parsedFlat = parseFlatFields(chosenText);
    if (dni) parsedFlat["N¬∫DOCUMENTO"]=dni;
    if (fec) parsedFlat["FECHA DE NACIMIENTO"]=fec;
    if (sex) parsedFlat["SEXO"]=sex;
    if (nat) parsedFlat["NACIONALIDAD"]=nat;

    return { text: chosenText, fields: parsedFlat };
  }

  // ===== Carga y disparo =====
  async function loadFromFile(file){
    try{
      statusEl.textContent='Cargando imagen‚Ä¶';
      const bmp = await createImageBitmap(file);
      const landscape = ensureLandscape(bmp);
      const base = cover16x9(landscape, OUT_W, OUT_H);

      // muestra lo que se usar√° (color base)
      ctx.clearRect(0,0,OUT_W,OUT_H); ctx.drawImage(base,0,0);

      statusEl.textContent='Procesando‚Ä¶';
      const { text, fields } = await fullPipeline(base);
      out.value = text;
      fieldsEl.textContent = JSON.stringify(fields, null, 2);
      exportEl.textContent = JSON.stringify(buildExportArray(fields), null, 2);
      statusEl.textContent='‚úÖ OCR completado.';
    }catch(e){
      console.error(e);
      statusEl.textContent='‚ùå Error en carga/OCR.';
    }
  }

  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadFromFile(f);
    e.target.value='';
  });
})();
</script>
</body>
</html>
