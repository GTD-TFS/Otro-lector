<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Buscar imagen ‚Üí EXIF OK ‚Üí OCR con campos</title>
<style>
  body{margin:0;background:#f6f7f9;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .app{max-width:920px;margin:0 auto;padding:1rem}
  .card{background:#fff;padding:1rem;border-radius:14px;box-shadow:0 8px 34px rgba(0,0,0,.06)}
  h1{margin:.25rem 0 1rem}
  #stage{width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;display:block}
  .toolbar{margin-top:.75rem;display:flex;gap:.5rem;justify-content:center;flex-wrap:wrap}
  label.btn,button{padding:.7rem 1rem;border-radius:10px;background:#111;color:#fff;cursor:pointer;border:none;font-size:1rem}
  label.btn input{display:none}
  button:disabled{opacity:.55;cursor:not-allowed}
  #status{margin-top:.5rem;text-align:center;color:#555;word-break:break-word}
  textarea{width:100%;min-height:140px;margin-top:.75rem}
  pre{background:#f7f7f7;border-radius:10px;padding:.7rem;white-space:pre-wrap}
  .row{display:flex;gap:1rem;justify-content:center;color:#555;align-items:center;margin-top:.5rem}
  input[type=range]{width:160px}
</style>
</head>
<body>
<div class="app">
  <div class="card">
    <h1>Imagen (EXIF corregido) ‚Üí OCR DNI</h1>

    <canvas id="stage"></canvas>
    <div id="status">Elige una foto del dispositivo. Se corregir√° la orientaci√≥n EXIF y se mostrar√° en horizontal 16:9.</div>

    <div class="row">
      <div>üåó Contraste OCR: <input id="contrast" type="range" min="0.8" max="2.2" step="0.05" value="1.6"></div>
      <div>üü° Brillo OCR: <input id="brightness" type="range" min="0.7" max="1.5" step="0.05" value="1.0"></div>
    </div>

    <div class="toolbar">
      <label class="btn">üñºÔ∏è Buscar en dispositivo
        <input id="file" type="file" accept="image/*">
      </label>
      <button id="ocr" disabled>üìñ Leer OCR</button>
    </div>

    <h3>Texto OCR</h3>
    <textarea id="out" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>

    <h3>Campos (normalizados)</h3>
    <pre id="fields"></pre>

    <h3>Array exportaci√≥n</h3>
    <pre id="exportArr"></pre>
  </div>
</div>

<!-- Tesseract -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script>
(() => {
  const stage = document.getElementById('stage');
  const ctx = stage.getContext('2d', { willReadFrequently:true });
  const statusEl = document.getElementById('status');
  const fileInput = document.getElementById('file');
  const ocrBtn = document.getElementById('ocr');
  const out = document.getElementById('out');
  const fieldsEl = document.getElementById('fields');
  const exportEl = document.getElementById('exportArr');
  const contrast = document.getElementById('contrast');
  const brightness = document.getElementById('brightness');

  // Canvas visible final (siempre horizontal 16:9)
  const OUT_W = 1600, OUT_H = 900;
  stage.width = OUT_W; stage.height = OUT_H;

  // Guardamos una copia del √∫ltimo canvas corregido para usar en OCR
  let lastCorrectedCanvas = null;

  // ---------- EXIF ----------
  async function readExifOrientation(file){
    try{
      const buf = await file.arrayBuffer();
      const view = new DataView(buf);
      if (view.getUint16(0,false) !== 0xFFD8) return 1; // no JPEG
      let offset = 2;
      while (offset < view.byteLength) {
        const marker = view.getUint16(offset, false); offset += 2;
        const size = view.getUint16(offset, false); offset += 2;
        if (marker === 0xFFE1) { // APP1 (Exif)
          if (view.getUint32(offset, false) !== 0x45786966) return 1; // "Exif"
          const tiff = offset + 6;
          const little = view.getUint16(tiff, false) === 0x4949;
          const get16 = (o) => view.getUint16(tiff + o, little);
          const get32 = (o) => view.getUint32(tiff + o, little);

          const ifd0 = get32(4);
          const entries = get16(ifd0);
          for (let i=0;i<entries;i++){
            const entry = ifd0 + 2 + i*12;
            const tag = get16(entry);
            if (tag === 0x0112){ // Orientation
              const val = get16(entry+8);
              return val || 1;
            }
          }
          return 1;
        } else {
          offset += size - 2;
        }
      }
    } catch(_){}
    return 1;
  }

  function applyOrientationToCanvas(imgBitmap, orientation){
    const sw = imgBitmap.width, sh = imgBitmap.height;
    let cw = sw, ch = sh;
    let rotate = 0, flipX = false, flipY = false;

    // 1:0¬∞, 2:flipX, 3:180¬∞, 4:flipY, 5:90¬∞+flipX, 6:90¬∞, 7:90¬∞+flipY, 8:270¬∞
    switch (orientation) {
      case 2: flipX = true; break;
      case 3: rotate = 180; break;
      case 4: flipY = true; break;
      case 5: rotate = 90; flipX = true; [cw,ch] = [sh,sw]; break;
      case 6: rotate = 90; [cw,ch] = [sh,sw]; break;
      case 7: rotate = 90; flipY = true; [cw,ch] = [sh,sw]; break;
      case 8: rotate = 270; [cw,ch] = [sh,sw]; break;
      default: break;
    }

    const c = document.createElement('canvas');
    c.width = cw; c.height = ch;
    const x = c.getContext('2d');

    x.save();
    if (rotate === 90) { x.translate(cw, 0); x.rotate(Math.PI/2); }
    else if (rotate === 180) { x.translate(cw, ch); x.rotate(Math.PI); }
    else if (rotate === 270) { x.translate(0, ch); x.rotate(3*Math.PI/2); }
    x.scale(flipX ? -1 : 1, flipY ? -1 : 1);
    x.drawImage(imgBitmap, 0, 0);
    x.restore();

    return c;
  }

  function shouldApplyExif(orient, bmp){
    if (orient === 1) return false;
    if ((orient === 6 || orient === 8)) {
      // si ya viene ancho>alto, probablemente el navegador aplic√≥ EXIF
      if (bmp.width > bmp.height) return false;
    }
    // 3 (180¬∞) o flips: no cambia ratio -> aplicar
    return true;
  }

  function drawCover16x9(srcCanvas){
    const sw = srcCanvas.width, sh = srcCanvas.height;
    const target = OUT_W / OUT_H, ratio = sw / sh;
    let sx, sy, cw, ch;
    if (ratio > target) {
      ch = sh; cw = Math.round(sh * target);
      sx = Math.round((sw - cw)/2); sy = 0;
    } else {
      cw = sw; ch = Math.round(sw / target);
      sx = 0; sy = Math.round((sh - ch)/2);
    }
    ctx.clearRect(0,0,OUT_W,OUT_H);
    ctx.drawImage(srcCanvas, sx, sy, cw, ch, 0, 0, OUT_W, OUT_H);
  }

  async function loadFromFile(file){
    statusEl.textContent = 'Cargando‚Ä¶';
    const orient = await readExifOrientation(file);
    const bmp = await createImageBitmap(file);

    let srcCanvas;
    if (shouldApplyExif(orient, bmp)) {
      srcCanvas = applyOrientationToCanvas(bmp, orient);
    } else {
      srcCanvas = document.createElement('canvas');
      srcCanvas.width = bmp.width; srcCanvas.height = bmp.height;
      srcCanvas.getContext('2d').drawImage(bmp, 0, 0);
    }

    drawCover16x9(srcCanvas);

    // guarda una copia corrigida para OCR
    lastCorrectedCanvas = document.createElement('canvas');
    lastCorrectedCanvas.width = OUT_W; lastCorrectedCanvas.height = OUT_H;
    lastCorrectedCanvas.getContext('2d').drawImage(stage, 0, 0);

    statusEl.textContent = `‚úÖ Cargada (EXIF=${orient}). Lista para OCR.`;
    ocrBtn.disabled = false;
  }

  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    try { await loadFromFile(f); }
    catch(err){ console.error(err); statusEl.textContent='‚ùå Error cargando la imagen.'; }
    finally { e.target.value=''; }
  });

  // ---------- OCR ----------
  function buildOCRInput(){
    // Hacemos B/N + contraste/brillo SOLO para el OCR
    const c = document.createElement('canvas');
    c.width = OUT_W; c.height = OUT_H;
    const x = c.getContext('2d', { willReadFrequently:true });
    x.drawImage(lastCorrectedCanvas, 0, 0);

    const data = x.getImageData(0,0,OUT_W,OUT_H);
    const d = data.data;
    const cst = parseFloat(contrast.value);
    const brt = parseFloat(brightness.value);
    for (let i=0;i<d.length;i+=4){
      let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      g = g * cst * brt; g = g<0?0:g>255?255:g;
      d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    x.putImageData(data,0,0);
    return c;
  }

  function norm(s){ return (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^\p{L}\p{N}\s]/gu,' ').replace(/\s+/g,' ').trim().toUpperCase(); }

  function parseDNI(text){
    const clean = norm(text);
    const out = {
      "Nombre": "",
      "APELLIDOS": "",
      "TIPO DOCUMENTO": "DNI",
      "N¬∫DOCUMENTO": "",
      "SEXO": "",
      "NACIONALIDAD": "",
      "Nombre de los Padres": "",
      "FECHA DE NACIMIENTO": "",
      "LUGAR DE NACIMIENTO": "",
      "DOMICILIO": ""
    };

    // N¬∫ de documento
    const mDni = clean.match(/\b\d{8}[A-Z]\b/);
    if (mDni) out["N¬∫DOCUMENTO"] = mDni[0];

    // Etiquetas t√≠picas
    const lines = clean.split(/\n| {2,}/);
    for (let i=0;i<lines.length;i++){
      const L = lines[i];
      if (L.includes("APELLID")) out["APELLIDOS"] = (lines[i+1]||"").split(' ').slice(0,4).join(' ').trim();
      if (L.includes("NOMBRE"))  out["Nombre"]    = (lines[i+1]||"").split(' ').slice(0,3).join(' ').trim();
      if (L.includes("SEXO") && L.includes("NACION")){
        // siguiente l√≠nea suele tener M/F + ESP + fecha
        const nxt = (lines[i+1]||'');
        const mS = nxt.match(/\b[MF]\b/); if (mS) out["SEXO"]=mS[0];
        const mN = nxt.match(/\b[A-Z]{3}\b/); if (mN) out["NACIONALIDAD"]=mN[0];
        const mF = nxt.match(/\b(\d{1,2})[\/.\-\s](\d{1,2})[\/.\-\s](\d{2,4})\b/);
        if (mF){ const dd=mF[1].padStart(2,'0'), mm=mF[2].padStart(2,'0'); const yy=mF[3].length===2?('19'+mF[3]):mF[3]; out["FECHA DE NACIMIENTO"]=`${dd}/${mm}/${yy}`; }
      }
    }

    // Si hay dos apellidos en l√≠neas separadas ya los juntamos arriba; si no, intenta fallback por bloque t√≠tulo
    if (!out["APELLIDOS"]){
      const apBlock = clean.match(/APELLID[^\n]*\n([A-Z√Å√â√ç√ì√ö√ú√ë' -]+)\n?([A-Z√Å√â√ç√ì√ö√ú√ë' -]+)?/);
      if (apBlock){
        const a1=(apBlock[1]||'').trim(), a2=(apBlock[2]||'').trim();
        out["APELLIDOS"]=[a1,a2].filter(Boolean).join(' ');
      }
    }

    return out;
  }

  function buildExportArray(data){
    const U = s => (s||'').toString();
    const domDisplay = data["DOMICILIO"] || "";
    return [
      ["Nombre", U(data["Nombre"])],
      ["Apellidos", U(data["APELLIDOS"])],
      ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
      ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
      ["Sexo", U(data["SEXO"])],
      ["Nacionalidad", U(data["NACIONALIDAD"])],
      ["Nombre de los Padres", U(data["Nombre de los Padres"])],
      ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
      ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
      ["Domicilio", U(domDisplay)],
    ];
  }

  document.getElementById('ocr').addEventListener('click', async () => {
    if (!lastCorrectedCanvas) return;
    out.value = 'Procesando OCR‚Ä¶';
    fieldsEl.textContent = ''; exportEl.textContent = '';

    const inputCanvas = buildOCRInput();
    const blob = await new Promise(res => inputCanvas.toBlob(res,'image/png',1));

    const worker = await Tesseract.createWorker('spa', 1, { logger: m => console.log(m) });
    const { data } = await worker.recognize(blob);
    await worker.terminate();

    const text = (data.text||'').trim();
    out.value = text;

    const parsed = parseDNI(text);
    fieldsEl.textContent = JSON.stringify(parsed, null, 2);

    const arr = buildExportArray(parsed);
    exportEl.textContent = JSON.stringify(arr, null, 2);

    statusEl.textContent = '‚úÖ OCR completado.';
  });
})();
</script>
</body>
</html>
